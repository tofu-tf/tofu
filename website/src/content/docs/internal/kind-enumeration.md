---
title: Kind numbers
---
# Kind numbers

Naming kinds is hard. Suppose you have `Function1[A, B] = A => B` and `FunctionK[F[_], G[_]] = [A] => F[A] => G[A]`

Suppose you have `T[_[_, _], _, _]` how to correctly name transformation between such types? `FunctionK_KK_KK` ?  
Alphabetical codes could be hard to read and disambiguate. So I propose enumerate them all with a simple scheme.

Here we suppose that `* = Type` is a Kind of  inhabitable types and `k1 -> k2` where `k1` and `k2` are kind is itself kind that has single type argument of kind `k1` and result of kind `k2`. Those arrows in absence of parenthesis are associated right.
All scala kinds we suppose to be naturally curried.  

So `T[_[_, _], _, _]` becomes `(* -> * -> *) -> * -> * -> *` or  `(* -> (* -> *)) -> (* -> (* -> *))`
and `T[_[_[_]], _[_[_]]]` becomes `((* -> *) -> *) -> ((* -> *) -> *) -> *` or `((* -> *) -> *) -> (((* -> *) -> *) -> *)`.

We can consider those elements as binary trees, elements of  

```scala
sealed trait Bin
case object Leaf extends Bin
case class Branch(l: Bin, r: Bin) extends Bin
```

`*` corresponds to `Leaf` and `k1 -> k2` corresponds to `Branch(k1, k2)`  
For those trees we defined rank as following:

```scala
lazy val rank: Bin => Int = {
    case Leaf => 0
    case Branch(b1, b2) => (rank(b1) max rank(b2)) + 1
}
```  

We can calculate count of different binary trees for each rank as follows:

```scala
val sizeUpToRank: LazyList[BigInt] = LazyList.from(0).map{x =>  
    if(x == 0) 0 else rankSize(x - 1) + sizeUpToRank(x - 1)
}
// sizeUpToRank: LazyList[BigInt] = LazyList(
//   0,
//   1,
//   2,
//   5,
//   26,
//   677,
//   458330,
//   210066388901,
//   44127887745906175987802,
//   1947270476915296449559703445493848930452791205,
//   3791862310265926082868235028027893277370233152247388584761734150717768254410341175325352026,
//   14378219780015246281818710879551167697596193767663736497089725524386087657390556152293078723153293423353330879856663164406809615688082297859526620035327291442156498380795040822304677,
//   206733204042421677181634718734036889377274379383357716793405865823317095368775657289542893376781635914484312173817557988370878548961245582641826131216636641404794790451610519266609830021136113094251414331751648388702965701984820995989371335396043070504172130112866209291049622803261659179113537278037525778584436702376761342360786599429657542977416989141816074330,
//   42738617653645554487425669417955367763548489178153791212890331885138890998900808508146311757939093198954220995963493880469893655060010272737530068485887533886750263319088128875100617961740172918691094829068947024559255417843694122849355986039999784721779678479610340520316257460780653331211115191175921001686550288449540320526606015935656176339986358350085020871937781528861776129372953594883435388246572243486971684762525383211187114336334622961088849148988499044550772500949253994140989436531257826950153336030112478731838434316764895787741660597458158488889333869972691535297977686181013053333952226427170791307608470557004650494024440810638395846001231063108520585007047155467529084874545828487195466969383678372084948901,
//   1826589438944503441233944903619374450505261905526216392190051569548555311191158288867132938991947712288591383352357588138810394060302387326270400600396570764614934427901378777366474525326749920624362632713940031612926606920439054397967548375833719159919910473895631392945311389708800463637987473929840325809307030010774766185391004135689734801234068539673581567775247599312241880503731683150081948935872832347373134284011181695810360683632037786770652414081815536574735547003101607812553534569242800170074276069350462692933568357952987062502907512783970461830300863082344583363776284175469786477682472528820908926526978015048109278721956581080776106925683386344085908595453026188666824003645568312836844393452776707185739880242765885532671069322802588959974057953754440241274547755740805666209468229826073218310424533265403717016863713464933481439043224331825817565164707656783863059616635780195412599299890019236436263930950584822203151741820151538481327313250894614525005135671096533093671101268517348570123352986058151565118846051377378244992162124290532840857906027057164086589991526364319002339012160251861903081354327843235434099982103607251422708178709813535095709323459574676499772530632263072416255064323426190667204706459937331048039207608155531772816982817842713722875518708173547418014456222314932091002591308523682124993038543498600578558907708385547242803907175849701173431239528379850308459943588194282093011602458634084954...

val rankSize: LazyList[BigInt] = LazyList.from(0).map{x =>
    if(x <= 1) 1  
    else 2 * sizeUpToRank(x - 1) * rankSize(x - 1) + rankSize(x - 1) * rankSize(x - 1)
}
// rankSize: LazyList[BigInt] = LazyList(
//   1,
//   1,
//   3,
//   21,
//   651,
//   457653,
//   210065930571,
//   44127887745696109598901,
//   1947270476915296449559659317606103024276803403,
//   3791862310265926082868235028027893277370233150300118107846437701158064808916492244872560821,
//   14378219780015246281818710879551167697596193767663736497089725524386087657390556152293078719361431113087404796988428136378916338317849145612138035273593140724388243970453865496952651,
//   206733204042421677181634718734036889377274379383357716793405865823317095368775657289542893376781635914484312173817557988370878548961245582641826131216636641404794790451610519266609815642916333079005132513040768837535268105791053332252874245670518684416514739556713916212326469509838305848233680614873118968968748620078901815740751272138215386479036194100993769653,
//   42738617653645554487425669417955367763548489178153791212890331885138890998900808508146311757939093198954220995963493880469893655060010272737530068485887533886750263319088128875100617961740172918691094829068947024559255417843694122849355986039999784721779678479610340520316257460780653331211115191175921001686550288449540320526606015935656176339986358350085020871731048324819354452191318876149398498869297864103613967969119517387870018967558965671545955772206863130066460327131696005770110887570012244308327204813475837327043643865154376521131830576322045394637919538221043146595011984196192057344580891031127720803436340444138441202974818007376736666887693785070994806422610453090767742513759229057537923991966689230268874571,
//   1826589438944503441233944903619374450505261905526216392190051569548555311191158288867132938991947712288591383352357588138810394060302387326270400600396570764614934427901378777366474525326749920624362632713940031612926606920439054397967548375833719159919910473895631392945311389708800463637987473929840325809307030010774766185391004135689734801234068539673581567775247599312241880503731683150081948935872832347373134284011181695810360683632037786770652414081815536574735547003101607812553534569242800170074276069350462692933568357952987062502907512783970461830300863082344583363776284175469786477682472528820908926526978015048109278721956581080776106925683386344085908595453026188666824003645568312836844393452776707185739880200027267879025514835376919542018690190205951063120756542850473781070577230925264710164112775326310518062642717501439600969149569271815544827634639170896329172866372461107283724199272057496263345239855755753256127182564733694787204463894908574525220413891418053483330580952259887789470021774942960389197844364827089795451841597684516905201729687070805736504970654426537473477236030878908308197918939596663190613010418844726039496991595477200472748234610425688000727979859762123162260923333989659409377756306601300935560475769721215007921195076182116264717029818839677445322920924337245909989537974571455697822247235890130021554257214361106432165511329848470110322718943372803152992414503319736264524406991664701276287696158901,
// ...
```

Now we can assign unique natural index to Binary trees inside the rank and globally

```scala
lazy val rankIndex: Bin => BigInt = {
    case Leaf => 0
    case tree@Branch(tl, tr) =>
        val r   = rank(tree) - 1
        val q   = rankSize(r)
        val u   = sizeUpToRank(r) * q
        if(rank(tl) < r)
            index(tl) * q + rankIndex(tr)
        else if(rank(tr) < r)
            index(tr) * q + rankIndex(tl) + u  
        else  
            rankIndex(tl) * q + rankIndex(tr) + 2 * u
}

def index(tree: Bin): BigInt = sizeUpToRank(rank(tree)) + rankIndex(tree)

index(Branch(Branch(Leaf, Leaf), Leaf))
// res0: BigInt = 3
```

We can provide string representations for our trees.

```scala
lazy val args: Bin => LazyList[Bin] = {
    case Leaf => LazyList.empty
    case Branch(t1, t2) => t1 #:: args(t2)
}

lazy val toStarString: Bin => String = {
    case Leaf => "*"
    case tree => args(tree).iterator.map {
        case Leaf => "*"
        case branch => s"(${toStarString(branch)})"
    }.mkString("", " -> ", " -> *")
}

lazy val toScalaString: Bin => String = {
    case Leaf => "T"
    case tree => args(tree).iterator.map {
        case Leaf => "_"
        case branch => s"_${toScalaString(branch)}"
    }.mkString("[", ", ", "]")
}
```

Now we can generate some trees

```scala
val trees = LazyList.iterate((LazyList[Bin](), LazyList[Bin](Leaf))){ case (prev, cur) =>  
    val xs = for(tl <- prev; tr <- cur) yield Branch(tl, tr)
    val ys = for(tr <- prev; tl <- cur) yield Branch(tl, tr)
    val zs = for(tl <- cur; tr <- cur)  yield Branch(tl, tr)
    val next = xs #::: ys #::: zs
    (prev #::: cur, next)
}.flatMap(_._2).map(t => (toScalaString(t), index(t)))
// trees: LazyList[(String, BigInt)] = LazyList(
//   ("T", 0),
//   ("[_]", 1),
//   ("[_, _]", 2),
//   ("[_[_]]", 3),
//   ("[_[_], _]", 4),
//   ("[_, _, _]", 5),
//   ("[_, _[_]]", 6),
//   ("[_, _[_], _]", 7),
//   ("[_[_], _, _]", 8),
//   ("[_[_], _[_]]", 9),
//   ("[_[_], _[_], _]", 10),
//   ("[_[_, _]]", 11),
//   ("[_[_[_]]]", 12),
//   ("[_[_[_], _]]", 13),
//   ("[_[_, _], _]", 14),
//   ("[_[_[_]], _]", 15),
//   ("[_[_[_], _], _]", 16),
//   ("[_[_, _], _, _]", 17),
//   ("[_[_, _], _[_]]", 18),
//   ("[_[_, _], _[_], _]", 19),
//   ("[_[_[_]], _, _]", 20),
//   ("[_[_[_]], _[_]]", 21),
//   ("[_[_[_]], _[_], _]", 22),
//   ("[_[_[_], _], _, _]", 23),
//   ("[_[_[_], _], _[_]]", 24),
//   ("[_[_[_], _], _[_], _]", 25),
//   ("[_, _, _, _]", 26),
//   ("[_, _, _[_]]", 27),
//   ("[_, _, _[_], _]", 28),
//   ("[_, _[_], _, _]", 29),
//   ("[_, _[_], _[_]]", 30),
//   ("[_, _[_], _[_], _]", 31),
//   ("[_, _[_, _]]", 32),
//   ("[_, _[_[_]]]", 33),
//   ("[_, _[_[_], _]]", 34),
//   ("[_, _[_, _], _]", 35),
//   ("[_, _[_[_]], _]", 36),
//   ("[_, _[_[_], _], _]", 37),
//   ("[_, _[_, _], _, _]", 38),
//   ("[_, _[_, _], _[_]]", 39),
//   ("[_, _[_, _], _[_], _]", 40),
//   ("[_, _[_[_]], _, _]", 41),
//   ("[_, _[_[_]], _[_]]", 42),
//   ("[_, _[_[_]], _[_], _]", 43),
//   ("[_, _[_[_], _], _, _]", 44),
//   ("[_, _[_[_], _], _[_]]", 45),
//   ("[_, _[_[_], _], _[_], _]", 46),
//   ("[_[_], _, _, _]", 47),
// ...
```

Here we can find that our desired shape for `[_[_, _], _, _]` has number 17

```scala
trees.find(_._1 == "[_[_, _], _, _]").get._2
// res1: BigInt = 17
```

Therefore we can name our kind-specific transformation as `FunctionKn17` meaning this is transformation between typeconstructors of type with index 17 having following form

```scala
type FunctionKn17[A[_[_, _], _, _], B[_[_, _], _, _]] = [F[_, _], E, A] => A[F, E, A] => B[F, E, A]
```

We can also reverse kind getting by index

```scala
def byIndex(x: BigInt): Bin = if(x == 0) Leaf else {
    val r = sizeUpToRank.indexWhere(_ > x) - 1
    byIndexInRank(x - sizeUpToRank(r), r)
}

def byIndexInRank(x: BigInt, r: Int): Bin = if(r == 0) Leaf else {
    val q = rankSize(r - 1)
    val u = sizeUpToRank(r - 1) * q
    if(x < u)
        Branch(byIndex(x / q), byIndexInRank(x % q, r - 1))
    else if(x < 2 * u){
        val x1 = x - u
        Branch(byIndexInRank(x1 % q, r - 1), byIndex(x1 / q))
    } else {
        val x1 = x - 2 * u
        Branch(byIndexInRank(x1 / q, r - 1), byIndexInRank(x1 % q, r - 1))
    }
}
```

we may check that these functions are indeed isomorphim in natural numbers

```scala
Iterator.range(0, 100).forall(i => index(byIndex(i)) == i)
// res2: Boolean = true
```

So now if one need to get signature for Kind number 17, they may write

```scala
toScalaString(byIndex(17))
// res3: String = "[_[_, _], _, _]"
toStarString(byIndex(17))
// res4: String = "(* -> * -> *) -> * -> * -> *"
```
