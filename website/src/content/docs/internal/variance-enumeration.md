---
title: Kind numbers with variance support
---
# Kind numbers with variance support

Naming kinds is hard. Especially with variance
Consider `Function1[-A, +B] = A => B` and `FunctionK[-F[_], +G[_]] = [A] => F[A] => G[A]`

Suppose you have now `T[_[-_, +_], -_, +_]` how to correctly name transformation between such types? `FunctionK_PM_PM` ?  
Alphabetical codes could be hard to read and disambiguate. So I propose enumerate them all with a simple scheme.

Here we suppose that `* = Type` is a Kind of inhabitable types and `[v]k1 -> k2` where `k1` and `k2` are kinds is itself a kind that has single type argument of kind `k1` and result of kind `k2`. And `[v]` is a variance annotation that could be `+`, `-` or empty, meaning invariant argument
 Those arrows in absence of parenthesis are associated right.

All scala kinds we suppose to be naturally curried.  

So `T[_[-_, +_], -_, +_]`  
becomes  `(-* -> +* -> *) -> -* -> -* -> *`  
or  `(-* -> (+* -> *)) -> (-* -> (+* -> *))`  
and `T[-_[_[_]], +_[_[_]]]`  
becomes `-((* -> *) -> *) -> +((* -> *) -> *) -> *`  
or `-((* -> *) -> *) -> +(((* -> *) -> *) -> *)`.

We can consider those elements as binary trees, elements of  

```scala
sealed trait Variance
case object VP extends Variance // plus  : covariant
case object VM extends Variance // minux : contravariant
case object VZ extends Variance // zero  : invariant

sealed trait Bin
case object Leaf extends Bin
case class Branch(v: Variance, l: Bin, r: Bin) extends Bin
```

`*` corresponds to `Leaf` and `[v]k1 -> k2` corresponds to `Branch(v, k1, k2)`  
For such trees we define rank as following:

```scala
lazy val rank: Bin => Int = {
    case Leaf => 0
    case Branch(_, b1, b2) => (rank(b1) max rank(b2)) + 1
}
```  

We can calculate count of different binary trees for each rank as follows:

```scala
val sizeUpToRank: LazyList[BigInt] = LazyList.from(0).map{x =>  
    if(x == 0) 0 else rankSize(x - 1) + sizeUpToRank(x - 1)
}
// sizeUpToRank: LazyList[BigInt] = LazyList(
//   0,
//   1,
//   4,
//   49,
//   7204,
//   155692849,
//   72720789689210404,
//   15864939759067110620365478945529649,
//   755088940676485169938738163710161860712676916415510672422283414189604,
//   1710477924995809620741466545281845877392776244459137496512119763532487257949748828346877281192891932326680051648814006422213934676185030449,
//   8777204195693911567685456624818652701352810989020881472462735774808494129194366672354313548546992725985867783409528459518360807197552168726303108340073231468228005400316009637445980374042337351867194500630013083675337492392623557213384815556591715323532442371044405945171424804,
//   231117940478720415213531437758395981779612055401727489007061251549584337033722648017278268997043331944793422425417147835136378653769228785180826873170803292070200962881100251725971234983367922271392500247243802459492492117984536255015645165165964208867355845380616890646607109058985424080623647679283990271608491010174719633013513533814269224342669738892396601966820323744148160302566876466384569583272577739989650397413110828035478239623075534083552447473721205052481025356390145628657289507988670848231995322172252217021762360439524461596518070279315249,
//   160246507233376057888095983946400008211351822986391919961667375491092120841195207706879637172649311212790319414854429458009034673347011434249077392770346783241578121135671156808427657387010368952095309901399258462191780631290757367662627562869543102758910577839074571844310832469946090964425485099041581224416204564838673679448027889956518931413492836045036864642103979998509935616868856220481791677573090517846649634334731092202168229074043650007647088568047380591203577649379437839450221552111437388320838854722861455634758241800521514340484532271192888080701246406039376020926608775795638100046305558670761054040792898680681011197516458799768326372369854365131487221856486163460785673202880959816636862080325912430729209881793588453374503814544947340489876868798682677147110685870859893177232841574242385645336577275376721303843475693586425653434013198444957617111891930743060369420100934441515202814481374267729939253591134243797349748174991973932841020034779271484062241759971035917323450866363965015833713674328348946282266062242982187351643898666059256597096269612015978524190104108993764347604971796004,
//   7703682924148933572737622303499584243566291396188029208027163112470143192054773098602261862914620829053803320509752885260765890714357378271657227072008971636003502342026979926955549155966896962188774205386859531322719946512500604909414526020801121695464446843680960907453578446513955446693643181715825027518962556706286671815525645080220684215451278634153154465644408198657772941883250234644988507906950528293241906199494524595926781722308789169773225516118200326036535141755591839304713900714117166638821348972893482692188186574368300812183762808263713578073397969923091874616994129069569036253864851963461539052858669286003211551106684708828059760409543825330039719624422193523781202732346109421353226733018183643288051526491570842066776792596947731921767392952558544522425388609631093113578062200647689274294720113843876550205067771853654044466859682455104648427337953934562095927850996311997655951443176619710553655154961936286457600077025478331559164362...

val rankSize: LazyList[BigInt] = LazyList.from(0).map{x =>
    if(x == 0) 1  
    else 3 * (2 * sizeUpToRank(x - 1) * rankSize(x - 1) + rankSize(x - 1) * rankSize(x - 1))
}
// rankSize: LazyList[BigInt] = LazyList(
//   1,
//   3,
//   45,
//   7155,
//   155685645,
//   72720789533517555,
//   15864939759067110547644689256319245,
//   755088940676485169938738163710161844847737157348400052056804468659955,
//   1710477924995809620741466545281845877392776244459137496512119763532486502860808151861707342454728222164819338971897590911541512392770840845,
//   8777204195693911567685456624818652701352810989020881472462735774808494129194366672354313548546992725985867783409528459518360807197552168724592630415077421847486538855034163760053204129583199855355074737097525825725588664045746276020492883229911663674718435948830471268986394355,
//   231117940478720415213531437758395981779612055401727489007061251549584337033722648017278268997043331944793422425417147835136378653769228785180826873170803292070200962881100251725971234983367922271392500247243802459492492117984536255015645165165964208867355845380616890646607109050208219884929736111598533646789838308821908643992632061351533449534175609698029929612506775197155434316699093056856110064911770542437481671110002487962246771395070133767542810027740831010143673489195644998644205832651178455608438108787436660430047036907082090552112125107890445,
//   160246507233376057888095983946400008211351822986391919961667375491092120841195207706879637172649311212790319414854429458009034673347011434249077392770346783241578121135671156808427657387010368952095309901399258462191780631290757367662627562869543102758910577839074571844310832469946090964425485099041581224416204564838673679448027889956518931413492836045036864642103979998509935616868856220481791677573090517846649634334731092202168229074043650007647088568047380591203577649379437839450221552111437388320838854722861455634758241800521514340484532271192887849583305927318960807395171017399656320434250156943272046979541349096343977474868441521499329329037909571709061804708651027082131903974095778989763691277033842229766328781541862482139520446622675947989629624996223184654992701334604877532067675610033518289491196658486074696734416708162345029786333914454686008620881756023427355906567120172290860144742481871127972433267390095637047181298525589363257747457039281833664828649143000439083827790829881463386239953123296465256909672097353530062135909995211024601774097359798956761829664584532167829534692480755,
//   770368292414893357273762230349958424356629139618802920802716311247014319205477309860226186291462082905380332050975288526076589071435737827165722707200897163600350234202697992695554915596689696218877420538685953132271994651250060490941452602080112169546444684368096090745357844651395544669364318171582502751896255670628667181552564508022068421545127863415315446564440819865777294188325023464498850790695052829324190619949452459592678172230878916977322551611820032603653514175559183930471390071411716663882134897289348269218818657436830081218376280826371357807339796992309187461699412906956903625386485196346153905285866928600321155110668470882805976040954382533003971962442219352378120273234610942135322673301818364328805152649157084206677679259694773192176739295255854452242538860963109311357806220064768927429472011384387655020506777185365404446685968245510464842733795393456209592785099631199765595144317661971055365515496193628645760007702547833155916436229463079280459924457646186515746810255782617251844242782546385959092833748525000...
```

Now we can assign unique natural index to Binary trees inside the rank and globally

```scala
lazy val varianceIndex: Variance => Int = {
    case VP => 0
    case VM => 1
    case VZ => 2
}

lazy val rankIndex: Bin => BigInt = {
    case Leaf => 0
    case tree@Branch(v, tl, tr) =>
        val r   = rank(tree) - 1
        val q   = rankSize(r)
        val u   = sizeUpToRank(r) * q
        val idx =  
        if(rank(tl) < r)
            index(tl) * q + rankIndex(tr)
        else if(rank(tr) < r)
            index(tr) * q + rankIndex(tl) + u  
        else  
            rankIndex(tl) * q + rankIndex(tr) + 2 * u
        idx * 3 + varianceIndex(v)
}

def index(tree: Bin): BigInt = sizeUpToRank(rank(tree)) + rankIndex(tree)

index(Branch(VM , Branch(VP, Leaf, Leaf), Leaf))
// res0: BigInt = 14
```

We can provide string representations for our trees.

```scala
lazy val varianceSign: Variance => String = {
    case VP => "+"
    case VM => "-"
    case VZ => ""
}

lazy val args: Bin => LazyList[(String, Bin)] = {
    case Leaf => LazyList.empty
    case Branch(v, t1, t2) => (varianceSign(v), t1) #:: args(t2)
}

lazy val toStarString: Bin => String = {
    case Leaf => "*"
    case tree => args(tree).iterator.map {
        case (sign, Leaf) => s"$sign*"
        case (sign, branch) => s"$sign(${toStarString(branch)})"
    }.mkString("", " -> ", " -> *")
}

lazy val toScalaString: Bin => String = {
    case Leaf => "T"
    case tree => args(tree).iterator.map {
        case (sign, Leaf) => s"${sign}_"
        case (sign, branch) => s"${sign}_${toScalaString(branch)}"
    }.mkString("[", ", ", "]")
}
```

Now we can generate some trees

```scala
val variances = LazyList(VP, VM, VZ)
// variances: LazyList[Product with Variance with Serializable] = LazyList(
//   VP,
//   VM,
//   VZ
// )
val trees = LazyList.iterate((LazyList[Bin](), LazyList[Bin](Leaf))){ case (prev, cur) =>  
    val xs = for(tl <- prev; tr <- cur; v <- variances) yield Branch(v, tl, tr)
    val ys = for(tr <- prev; tl <- cur; v <- variances) yield Branch(v, tl, tr)
    val zs = for(tl <- cur; tr <- cur; v <- variances)  yield Branch(v, tl, tr)
    val next = xs #::: ys #::: zs
    (prev #::: cur, next)
}.flatMap(_._2).map(t => (index(t), toScalaString(t), toStarString(t)))
// trees: LazyList[(BigInt, String, String)] = LazyList(
//   (0, "T", "*"),
//   (1, "[+_]", "+* -> *"),
//   (2, "[-_]", "-* -> *"),
//   (3, "[_]", "* -> *"),
//   (4, "[+_, +_]", "+* -> +* -> *"),
//   (5, "[-_, +_]", "-* -> +* -> *"),
//   (6, "[_, +_]", "* -> +* -> *"),
//   (7, "[+_, -_]", "+* -> -* -> *"),
//   (8, "[-_, -_]", "-* -> -* -> *"),
//   (9, "[_, -_]", "* -> -* -> *"),
//   (10, "[+_, _]", "+* -> * -> *"),
//   (11, "[-_, _]", "-* -> * -> *"),
//   (12, "[_, _]", "* -> * -> *"),
//   (13, "[+_[+_]]", "+(+* -> *) -> *"),
//   (14, "[-_[+_]]", "-(+* -> *) -> *"),
//   (15, "[_[+_]]", "(+* -> *) -> *"),
//   (16, "[+_[-_]]", "+(-* -> *) -> *"),
//   (17, "[-_[-_]]", "-(-* -> *) -> *"),
//   (18, "[_[-_]]", "(-* -> *) -> *"),
//   (19, "[+_[_]]", "+(* -> *) -> *"),
//   (20, "[-_[_]]", "-(* -> *) -> *"),
//   (21, "[_[_]]", "(* -> *) -> *"),
//   (22, "[+_[+_], +_]", "+(+* -> *) -> +* -> *"),
//   (23, "[-_[+_], +_]", "-(+* -> *) -> +* -> *"),
//   (24, "[_[+_], +_]", "(+* -> *) -> +* -> *"),
//   (25, "[+_[+_], -_]", "+(+* -> *) -> -* -> *"),
//   (26, "[-_[+_], -_]", "-(+* -> *) -> -* -> *"),
//   (27, "[_[+_], -_]", "(+* -> *) -> -* -> *"),
//   (28, "[+_[+_], _]", "+(+* -> *) -> * -> *"),
//   (29, "[-_[+_], _]", "-(+* -> *) -> * -> *"),
//   (30, "[_[+_], _]", "(+* -> *) -> * -> *"),
//   (31, "[+_[-_], +_]", "+(-* -> *) -> +* -> *"),
//   (32, "[-_[-_], +_]", "-(-* -> *) -> +* -> *"),
//   (33, "[_[-_], +_]", "(-* -> *) -> +* -> *"),
//   (34, "[+_[-_], -_]", "+(-* -> *) -> -* -> *"),
//   (35, "[-_[-_], -_]", "-(-* -> *) -> -* -> *"),
//   (36, "[_[-_], -_]", "(-* -> *) -> -* -> *"),
//   (37, "[+_[-_], _]", "+(-* -> *) -> * -> *"),
//   (38, "[-_[-_], _]", "-(-* -> *) -> * -> *"),
//   (39, "[_[-_], _]", "(-* -> *) -> * -> *"),
//   (40, "[+_[_], +_]", "+(* -> *) -> +* -> *"),
//   (41, "[-_[_], +_]", "-(* -> *) -> +* -> *"),
//   (42, "[_[_], +_]", "(* -> *) -> +* -> *"),
//   (43, "[+_[_], -_]", "+(* -> *) -> -* -> *"),
//   (44, "[-_[_], -_]", "-(* -> *) -> -* -> *"),
//   (45, "[_[_], -_]", "(* -> *) -> -* -> *"),
//   (46, "[+_[_], _]", "+(* -> *) -> * -> *"),
//   (47, "[-_[_], _]", "-(* -> *) -> * -> *"),
// ...
```

Here we can find that our desired shape for `[_[-_, +_], -_, +_]` has number 1269

```scala
trees.find(_._2 == "[_[-_, +_], -_, +_]").get._1
// res1: BigInt = 1269
```

Therefore we can name our kind-specific transformation as `FunctionVn1269` meaning this is transformation between typeconstructors of type with index 1269 having following form

```scala
type FunctionVn1269[A[_[-_, +_], -_, +_], B[_[-_, +_], -_, +_]] = [F[-_, +_], E, A] => A[F, E, A] => B[F, E, A]
```

We can also reverse kind getting by index

```scala
def byIndex(x: BigInt): Bin = if(x == 0) Leaf else {
    val r = sizeUpToRank.indexWhere(_ > x) - 1
    byIndexInRank(x - sizeUpToRank(r), r)
}

def varByIndex: Int => Variance = {
    case 0 => VP
    case 1 => VM
    case 2 => VZ
}

def byIndexInRank(x: BigInt, r: Int): Bin = if(r == 0) Leaf else {
    val q = rankSize(r - 1)
    val u = sizeUpToRank(r - 1) * q
    val v = varByIndex((x % 3).toInt)
    val x0 = x / 3
    if(x0 < u)
        Branch(v, byIndex(x0 / q), byIndexInRank(x0 % q, r - 1))
    else if(x0 < 2 * u){
        val x1 = x0 - u
        Branch(v, byIndexInRank(x1 % q, r - 1), byIndex(x1 / q))
    } else {
        val x1 = x0 - 2 * u
        Branch(v, byIndexInRank(x1 / q, r - 1), byIndexInRank(x1 % q, r - 1))
    }
}
```

we may check that these functions are indeed isomorphim in natural numbers

```scala
Iterator.range(0, 1000).forall(i => index(byIndex(i)) == i)
// res2: Boolean = true
```

So now if one need to get signature for Kind number 17, they may write

```scala
toScalaString(byIndex(1269))
// res3: String = "[_[-_, +_], -_, +_]"
toStarString(byIndex(1269))
// res4: String = "(-* -> +* -> *) -> -* -> +* -> *"
```
