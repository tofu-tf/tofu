"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9917],{5680:(e,n,a)=>{a.d(n,{xA:()=>p,yg:()=>y});var r=a(6540);function t(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),a.push.apply(a,r)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach(function(n){t(e,n,a[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))})}return e}function o(e,n){if(null==e)return{};var a,r,t=function(e,n){if(null==e)return{};var a,r,t={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||(t[a]=e[a]);return t}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var s=r.createContext({}),c=function(e){var n=r.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},p=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},d="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef(function(e,n){var a=e.components,t=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(a),m=t,y=d["".concat(s,".").concat(m)]||d[m]||g[m]||i;return a?r.createElement(y,l(l({ref:n},p),{},{components:a})):r.createElement(y,l({ref:n},p))});function y(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var i=a.length,l=new Array(i);l[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:t,l[1]=o;for(var c=2;c<i;c++)l[c]=a[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7910:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>y,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var r=a(8168),t=a(8587),i=(a(6540),a(5680)),l=["components"],o={},s="Kind numbers with variance support",c={unversionedId:"internal/variance-enumeration",id:"internal/variance-enumeration",title:"Kind numbers with variance support",description:"Naming kinds is hard. Especially with variance",source:"@site/../docs/internal/variance-enumeration.md",sourceDirName:"internal",slug:"/internal/variance-enumeration",permalink:"/tofu/docs/internal/variance-enumeration",draft:!1,tags:[],version:"current",lastUpdatedBy:"Vadim Chelyshov",lastUpdatedAt:1752503915,formattedLastUpdatedAt:"Jul 14, 2025",frontMatter:{}},p={},d=[],g={toc:d},m="wrapper";function y(e){var n=e.components,a=(0,t.A)(e,l);return(0,i.yg)(m,(0,r.A)({},g,a,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"kind-numbers-with-variance-support"},"Kind numbers with variance support"),(0,i.yg)("p",null,"Naming kinds is hard. Especially with variance\nConsider ",(0,i.yg)("inlineCode",{parentName:"p"},"Function1[-A, +B] = A => B")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"FunctionK[-F[_], +G[_]] = [A] => F[A] => G[A]")),(0,i.yg)("p",null,"Suppose you have now ",(0,i.yg)("inlineCode",{parentName:"p"},"T[_[-_, +_], -_, +_]")," how to correctly name transformation between such types? ",(0,i.yg)("inlineCode",{parentName:"p"},"FunctionK_PM_PM")," ?",(0,i.yg)("br",{parentName:"p"}),"\n","Alphabetical codes could be hard to read and disambiguate. So I propose enumerate them all with a simple scheme."),(0,i.yg)("p",null,"Here we suppose that ",(0,i.yg)("inlineCode",{parentName:"p"},"* = Type")," is a Kind of inhabitable types and ",(0,i.yg)("inlineCode",{parentName:"p"},"[v]k1 -> k2")," where ",(0,i.yg)("inlineCode",{parentName:"p"},"k1")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"k2")," are kinds is itself a kind that has single type argument of kind ",(0,i.yg)("inlineCode",{parentName:"p"},"k1")," and result of kind ",(0,i.yg)("inlineCode",{parentName:"p"},"k2"),". And ",(0,i.yg)("inlineCode",{parentName:"p"},"[v]")," is a variance annotation that could be ",(0,i.yg)("inlineCode",{parentName:"p"},"+"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"-")," or empty, meaning invariant argument\nThose arrows in absence of parenthesis are associated right."),(0,i.yg)("p",null,"All scala kinds we suppose to be naturally curried.  "),(0,i.yg)("p",null,"So ",(0,i.yg)("inlineCode",{parentName:"p"},"T[_[-_, +_], -_, +_]"),(0,i.yg)("br",{parentName:"p"}),"\n","becomes  ",(0,i.yg)("inlineCode",{parentName:"p"},"(-* -> +* -> *) -> -* -> -* -> *"),(0,i.yg)("br",{parentName:"p"}),"\n","or  ",(0,i.yg)("inlineCode",{parentName:"p"},"(-* -> (+* -> *)) -> (-* -> (+* -> *))"),(0,i.yg)("br",{parentName:"p"}),"\n","and ",(0,i.yg)("inlineCode",{parentName:"p"},"T[-_[_[_]], +_[_[_]]]"),(0,i.yg)("br",{parentName:"p"}),"\n","becomes ",(0,i.yg)("inlineCode",{parentName:"p"},"-((* -> *) -> *) -> +((* -> *) -> *) -> *"),(0,i.yg)("br",{parentName:"p"}),"\n","or ",(0,i.yg)("inlineCode",{parentName:"p"},"-((* -> *) -> *) -> +(((* -> *) -> *) -> *)"),"."),(0,i.yg)("p",null,"We can consider those elements as binary trees, elements of  "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"sealed trait Variance\ncase object VP extends Variance // plus  : covariant\ncase object VM extends Variance // minux : contravariant\ncase object VZ extends Variance // zero  : invariant\n\nsealed trait Bin\ncase object Leaf extends Bin\ncase class Branch(v: Variance, l: Bin, r: Bin) extends Bin\n")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"*")," corresponds to ",(0,i.yg)("inlineCode",{parentName:"p"},"Leaf")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"[v]k1 -> k2")," corresponds to ",(0,i.yg)("inlineCode",{parentName:"p"},"Branch(v, k1, k2)"),(0,i.yg)("br",{parentName:"p"}),"\n","For such trees we define rank as following:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"lazy val rank: Bin => Int = {\n    case Leaf => 0\n    case Branch(_, b1, b2) => (rank(b1) max rank(b2)) + 1\n}\n")),(0,i.yg)("p",null,"We can calculate count of different binary trees for each rank as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"val sizeUpToRank: LazyList[BigInt] = LazyList.from(0).map{x =>  \n    if(x == 0) 0 else rankSize(x - 1) + sizeUpToRank(x - 1)\n}\n\nval rankSize: LazyList[BigInt] = LazyList.from(0).map{x =>\n    if(x == 0) 1  \n    else 3 * (2 * sizeUpToRank(x - 1) * rankSize(x - 1) + rankSize(x - 1) * rankSize(x - 1))\n}\n")),(0,i.yg)("p",null,"Now we can assign unique natural index to Binary trees inside the rank and globally"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"lazy val varianceIndex: Variance => Int = {\n    case VP => 0\n    case VM => 1\n    case VZ => 2\n}\n\nlazy val rankIndex: Bin => BigInt = {\n    case Leaf => 0\n    case tree@Branch(v, tl, tr) =>\n        val r   = rank(tree) - 1\n        val q   = rankSize(r)\n        val u   = sizeUpToRank(r) * q\n        val idx =  \n        if(rank(tl) < r)\n            index(tl) * q + rankIndex(tr)\n        else if(rank(tr) < r)\n            index(tr) * q + rankIndex(tl) + u  \n        else  \n            rankIndex(tl) * q + rankIndex(tr) + 2 * u\n        idx * 3 + varianceIndex(v)\n}\n\ndef index(tree: Bin): BigInt = sizeUpToRank(rank(tree)) + rankIndex(tree)\n\nindex(Branch(VM , Branch(VP, Leaf, Leaf), Leaf))\n")),(0,i.yg)("p",null,"We can provide string representations for our trees."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},'lazy val varianceSign: Variance => String = {\n    case VP => "+"\n    case VM => "-"\n    case VZ => ""\n}\n\nlazy val args: Bin => LazyList[(String, Bin)] = {\n    case Leaf => LazyList.empty\n    case Branch(v, t1, t2) => (varianceSign(v), t1) #:: args(t2)\n}\n\nlazy val toStarString: Bin => String = {\n    case Leaf => "*"\n    case tree => args(tree).iterator.map {\n        case (sign, Leaf) => s"$sign*"\n        case (sign, branch) => s"$sign(${toStarString(branch)})"\n    }.mkString("", " -> ", " -> *")\n}\n\nlazy val toScalaString: Bin => String = {\n    case Leaf => "T"\n    case tree => args(tree).iterator.map {\n        case (sign, Leaf) => s"${sign}_"\n        case (sign, branch) => s"${sign}_${toScalaString(branch)}"\n    }.mkString("[", ", ", "]")\n}\n')),(0,i.yg)("p",null,"Now we can generate some trees"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"val variances = LazyList(VP, VM, VZ)\nval trees = LazyList.iterate((LazyList[Bin](), LazyList[Bin](Leaf))){ case (prev, cur) =>  \n    val xs = for(tl <- prev; tr <- cur; v <- variances) yield Branch(v, tl, tr)\n    val ys = for(tr <- prev; tl <- cur; v <- variances) yield Branch(v, tl, tr)\n    val zs = for(tl <- cur; tr <- cur; v <- variances)  yield Branch(v, tl, tr)\n    val next = xs #::: ys #::: zs\n    (prev #::: cur, next)\n}.flatMap(_._2).map(t => (index(t), toScalaString(t), toStarString(t)))\n")),(0,i.yg)("p",null,"Here we can find that our desired shape for ",(0,i.yg)("inlineCode",{parentName:"p"},"[_[-_, +_], -_, +_]")," has number 1269"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},'trees.find(_._2 == "[_[-_, +_], -_, +_]").get._1\n')),(0,i.yg)("p",null,"Therefore we can name our kind-specific transformation as ",(0,i.yg)("inlineCode",{parentName:"p"},"FunctionVn1269")," meaning this is transformation between typeconstructors of type with index 1269 having following form"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"type FunctionVn1269[A[_[-_, +_], -_, +_], B[_[-_, +_], -_, +_]] = [F[-_, +_], E, A] => A[F, E, A] => B[F, E, A]\n")),(0,i.yg)("p",null,"We can also reverse kind getting by index"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"def byIndex(x: BigInt): Bin = if(x == 0) Leaf else {\n    val r = sizeUpToRank.indexWhere(_ > x) - 1\n    byIndexInRank(x - sizeUpToRank(r), r)\n}\n\ndef varByIndex: Int => Variance = {\n    case 0 => VP\n    case 1 => VM\n    case 2 => VZ\n}\n\ndef byIndexInRank(x: BigInt, r: Int): Bin = if(r == 0) Leaf else {\n    val q = rankSize(r - 1)\n    val u = sizeUpToRank(r - 1) * q\n    val v = varByIndex((x % 3).toInt)\n    val x0 = x / 3\n    if(x0 < u)\n        Branch(v, byIndex(x0 / q), byIndexInRank(x0 % q, r - 1))\n    else if(x0 < 2 * u){\n        val x1 = x0 - u\n        Branch(v, byIndexInRank(x1 % q, r - 1), byIndex(x1 / q))\n    } else {\n        val x1 = x0 - 2 * u\n        Branch(v, byIndexInRank(x1 / q, r - 1), byIndexInRank(x1 % q, r - 1))\n    }\n}\n")),(0,i.yg)("p",null,"we may check that these functions are indeed isomorphim in natural numbers"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"Iterator.range(0, 1000).forall(i => index(byIndex(i)) == i)\n")),(0,i.yg)("p",null,"So now if one need to get signature for Kind number 17, they may write"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"toScalaString(byIndex(1269))\ntoStarString(byIndex(1269))\n")))}y.isMDXComponent=!0}}]);