"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7026],{4137:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>m});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function c(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?c(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},c=Object.keys(e);for(r=0;r<c.length;r++)t=c[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(r=0;r<c.length;r++)t=c[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var f=r.createContext({}),l=function(e){var n=r.useContext(f),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},s=function(e){var n=l(e.components);return r.createElement(f.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,c=e.originalType,f=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),p=l(t),d=a,m=p["".concat(f,".").concat(d)]||p[d]||u[d]||c;return t?r.createElement(m,o(o({ref:n},s),{},{components:t})):r.createElement(m,o({ref:n},s))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var c=t.length,o=new Array(c);o[0]=d;var i={};for(var f in n)hasOwnProperty.call(n,f)&&(i[f]=n[f]);i.originalType=e,i[p]="string"==typeof e?e:a,o[1]=i;for(var l=2;l<c;l++)o[l]=t[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},8499:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>f,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=t(7462),a=t(3366),c=(t(7294),t(4137)),o=["components"],i={id:"concurrent-makeref",title:"MakeRef"},f=void 0,l={unversionedId:"concurrent-makeref",id:"concurrent-makeref",title:"MakeRef",description:"Cats-Effect: Ref",source:"@site/../docs/concurrent-makeref.md",sourceDirName:".",slug:"/concurrent-makeref",permalink:"/docs/concurrent-makeref",draft:!1,tags:[],version:"current",lastUpdatedBy:"Matt Kohl",lastUpdatedAt:1666373101,formattedLastUpdatedAt:"Oct 21, 2022",frontMatter:{id:"concurrent-makeref",title:"MakeRef"},sidebar:"docs",previous:{title:"Agent",permalink:"/docs/agent"},next:{title:"Mid",permalink:"/docs/mid"}},s={},p=[{value:"Cats-Effect: Ref",id:"cats-effect-ref",level:2},{value:"Tofu: MakeRef",id:"tofu-makeref",level:2},{value:"Ref creation",id:"ref-creation",level:3}],u={toc:p},d="wrapper";function m(e){var n=e.components,t=(0,a.Z)(e,o);return(0,c.kt)(d,(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,c.kt)("h2",{id:"cats-effect-ref"},"Cats-Effect: Ref"),(0,c.kt)("p",null,"An asynchronous, concurrent mutable reference."),(0,c.kt)("p",null,"Ref is a mutable reference which is non-blocking, accessed and modified concurrently, modified atomically and dealt with using only pure functions. The default implementation is nonblocking and lightweight, consisting essentially of a purely functional wrapper over an AtomicReference."),(0,c.kt)("p",null,"Provides safe concurrent access and modification of its content, but no functionality for synchronisation, which is instead handled by Deferred.\nFor this reason, a Ref is always initialised to a value."),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-scala"},"abstract class Ref[F[_], A] {\n  def get: F[A]\n  def set(a: A): F[Unit]\n  def modify[B](f: A => (A, B)): F[B]\n  def update(f: A => A): F[Unit]\n  // ... and more\n}\n")),(0,c.kt)("p",null,"Ref's companion object contains some methods which creates new Ref instance:"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-scala"},"import cats.effect.Sync\nimport cats.effect.concurrent.Ref\n\nobject Ref {\n    def of[F[_], A](a: A)(implicit F: Sync[F]): F[Ref[F, A]]  = ???\n    def in[F[_], G[_], A](a: A)(implicit F: Sync[F], G: Sync[G]): F[Ref[G, A]] = ???\n    //...\n}\n")),(0,c.kt)("p",null,"In fact, mutable content modifying is a side effect. Creating of mutable reference itself is a side effect too. Sometimes Ref helps to solve by offering some method to create instance which takes one or two type parameters as effect constructors.\nAlthough, this method needs to be given Sync instances for our effects. "),(0,c.kt)("h2",{id:"tofu-makeref"},"Tofu: MakeRef"),(0,c.kt)("p",null,"Tofu offers an easy and understandable initializer for Ref.  "),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-scala"},"import cats.effect.concurrent.Ref\n\ntrait MakeRef[I[_], F[_]] {\n  def refOf[A](a: A): I[Ref[F, A]]\n}\n")),(0,c.kt)("p",null,"MakeRef has a companion object that offers easier initialization of Ref instances.\nThere is defined implicit syncInstance that helps in creating Ref on Sync based effects."),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-scala"},"import cats.effect.Sync\nimport tofu.concurrent.MakeRef\n\nobject MakeRef {\n  def apply[I[_], F[_]](implicit makeRef: MakeRef[I, F]) = ???\n  implicit def syncInstance[I[_]: Sync, F[_]: Sync]: MakeRef[I, F] = ???\n}\n")),(0,c.kt)("h3",{id:"ref-creation"},"Ref creation"),(0,c.kt)("p",null,"You can use object ",(0,c.kt)("inlineCode",{parentName:"p"},"MakeRef")," that can produce values of type ",(0,c.kt)("inlineCode",{parentName:"p"},"I[Ref[F]]")," (where ",(0,c.kt)("inlineCode",{parentName:"p"},"I")," and ",(0,c.kt)("inlineCode",{parentName:"p"},"F")," can be two different effects) and initialize it with ,\nfor example:  "),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-scala"},"import cats.effect.IO\nimport tofu.concurrent.MakeRef\n\ndef program: IO[(Int,Int)] =\n    for {\n      ref <- MakeRef[IO,IO].of[Int](42)\n      c1  <- ref.get\n      _   <- ref.modify(x => (x + 1, x))\n      c2  <- ref.get\n    } yield (c1,c2)\n\nprogram.unsafeRunSync() // (42, 43)\n")),(0,c.kt)("p",null,"You can simplify this by using Refs[F[]] type alias defined in ",(0,c.kt)("inlineCode",{parentName:"p"},"tofu.concurrent")," package object. "),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-scala"},"import cats.effect.IO\nimport tofu.concurrent.Refs\n\nfor {\n    ref <- Refs[IO].of[Int](42)\n    c1  <- ref.get\n    _   <- ref.modify(x => (x + 1, x))\n    c2  <- ref.get\n} yield (c1,c2)\n")),(0,c.kt)("p",null,"You can also omit the explicit indication of the value type."),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre",className:"language-scala"},"import cats.effect.IO\nimport tofu.concurrent.Refs\n\nfor {\n    ref <- Refs[IO].of(42)\n    c1  <- ref.get\n    _   <- ref.modify(x => (x + 1, x))\n    c2  <- ref.get\n} yield (c1,c2)\n")))}m.isMDXComponent=!0}}]);