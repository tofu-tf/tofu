"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1851],{5680:(e,n,a)=>{a.d(n,{xA:()=>d,yg:()=>c});var t=a(6540);function o(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),a.push.apply(a,t)}return a}function r(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach(function(n){o(e,n,a[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))})}return e}function l(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},i=Object.keys(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var p=t.createContext({}),s=function(e){var n=t.useContext(p),a=n;return e&&(a="function"==typeof e?e(n):r(r({},n),e)),a},d=function(e){var n=s(e.components);return t.createElement(p.Provider,{value:n},e.children)},g="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},f=t.forwardRef(function(e,n){var a=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),g=s(a),f=o,c=g["".concat(p,".").concat(f)]||g[f]||m[f]||i;return a?t.createElement(c,r(r({ref:n},d),{},{components:a})):t.createElement(c,r({ref:n},d))});function c(e,n){var a=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=a.length,r=new Array(i);r[0]=f;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[g]="string"==typeof e?e:o,r[1]=l;for(var s=2;s<i;s++)r[s]=a[s];return t.createElement.apply(null,r)}return t.createElement.apply(null,a)}f.displayName="MDXCreateElement"},7147:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>p,default:()=>c,frontMatter:()=>l,metadata:()=>s,toc:()=>g});var t=a(8168),o=a(8587),i=(a(6540),a(5680)),r=["components"],l={},p="Bimonad tutorial",s={unversionedId:"internal/bimonad",id:"internal/bimonad",title:"Bimonad tutorial",description:"Bifunctors have become a hot topic in the Scala community since ZIO introduced the second type parameter.",source:"@site/../docs/internal/bimonad.md",sourceDirName:"internal",slug:"/internal/bimonad",permalink:"/tofu/docs/internal/bimonad",draft:!1,tags:[],version:"current",lastUpdatedBy:"Colby Cellador",lastUpdatedAt:1642771404,formattedLastUpdatedAt:"Jan 21, 2022",frontMatter:{}},d={},g=[{value:"Monads",id:"monads",level:2},{value:"Category",id:"category",level:3},{value:"Functor",id:"functor",level:3},{value:"Transformations",id:"transformations",level:3},{value:"Monad",id:"monad",level:3},{value:"Bifunctors",id:"bifunctors",level:2},{value:"Product of categories",id:"product-of-categories",level:3},{value:"Bifunctor",id:"bifunctor",level:3},{value:"Bifunctor monad",id:"bifunctor-monad",level:3},{value:"Twin monad",id:"twin-monad",level:3},{value:"Symmetry",id:"symmetry",level:3},{value:"Stack safety",id:"stack-safety",level:3}],m={toc:g},f="wrapper";function c(e){var n=e.components,a=(0,o.A)(e,r);return(0,i.yg)(f,(0,t.A)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"bimonad-tutorial"},"Bimonad tutorial"),(0,i.yg)("p",null,"Bifunctors have become a hot topic in the Scala community since ZIO introduced the second type parameter.\nIt's a great way to manage business errors in your code, but it lacks suitable abstractions.\nThe most comprehensive set I've seen lies ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/7mind/izumi/tree/develop/fundamentals/fundamentals-bio/src/main/scala/izumi/functional/bio"},"here"),".\nBut it's built upon practical usage.\nSo let's start building a more principled approach. "),(0,i.yg)("h2",{id:"monads"},"Monads"),(0,i.yg)("p",null,"Let's talk about the basic definitions. We will use the basic category theory terminology, most of which can be found on ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Monad_(functional_programming)"},"Wikipedia")," and ",(0,i.yg)("a",{parentName:"p",href:"https://ncatlab.org/nlab/show/monad"},"nLab"),".\nWe will use the following definitions."),(0,i.yg)("h3",{id:"category"},"Category"),(0,i.yg)("p",null,"Starting from this section, we will think of a Category as some entity with some additional structure.\nThe class mentioned below is something like a Set or a Type. Its elements are objects of the category. Since we want the object class to be arbitrary big (bigger than the classic Set could be) and we do not need equality/identity relation on it, we will denote it ",(0,i.yg)("em",{parentName:"p"},"Class"),"."),(0,i.yg)("p",null,"A ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Category_(mathematics)"},"category")," ",(0,i.yg)("inlineCode",{parentName:"p"},"C")," is a Class called ",(0,i.yg)("em",{parentName:"p"},"objects")," together with an indexed set family ",(0,i.yg)("inlineCode",{parentName:"p"},"Hom: (C, C) -> Set")," and functions"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"id : \u2200(a: C), Hom(a, a)\n\n\u2218 : \u2200{a, b, c : C}, (Hom(b, c), Hom(a, b)) -> Hom(a, c) \n")),(0,i.yg)("p",null,"and the following properties"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"left-id : \u2200{a, b: C}, \u2200(f: Hom(a, b)), id b \u2218 f = f\n\nright-id : \u2200{a, b: C}, \u2200(f: Hom(a, b)), f \u2218 id a = f\n\nassociativity : \u2200{a, b, c, d: C}, \u2200(f: Hom(c, d)), \u2200(g: Hom(b, c)), \u2200(h: Hom(c, d)), \u2200(h: Hom(a, b)), f \u2218 (g \u2218 h) = (f \u2218 g) \u2218 h\n")),(0,i.yg)("p",null,"The most acknowledged category in a functional programming language is a ",(0,i.yg)("inlineCode",{parentName:"p"},"Set"),"-like category of inhabitable types and pure total functions between them, so the objects are types, and for types ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"B")," ",(0,i.yg)("inlineCode",{parentName:"p"},"Hom(A, B)")," is a set of pure functions ",(0,i.yg)("inlineCode",{parentName:"p"},"A => B"),". For Scala, we will call it ",(0,i.yg)("inlineCode",{parentName:"p"},"Scala"),"."),(0,i.yg)("p",null,"Another sort of category that Scala types form is subtyping relations, i.e. we have a single element ",(0,i.yg)("inlineCode",{parentName:"p"},"Hom(A, B)")," when ",(0,i.yg)("inlineCode",{parentName:"p"},"A <: B")," and an empty Hom otherwise."),(0,i.yg)("h3",{id:"functor"},"Functor"),(0,i.yg)("p",null,"A functor ",(0,i.yg)("inlineCode",{parentName:"p"},"F")," between categories ",(0,i.yg)("inlineCode",{parentName:"p"},"C")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"D")," is a function ",(0,i.yg)("inlineCode",{parentName:"p"},"C -> D")," together with a family of functions"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"map: \u2200(a, b: C), Hom(a, b) -> Hom(F(a), F(b))\n")),(0,i.yg)("p",null,"and the following properties"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"functor-id: \u2200(a: C), map(F)(id a) = id b\nfunctor-compose: \u2200(a, b, c: C), \u2200(f: Hom(b, c), g: Hom(a, b)),  map{F}(f \u2218 g) = map{F}(f) \u2218 map{F}(g)\n")),(0,i.yg)("p",null,"The most beloved form of functors are endo-functors ",(0,i.yg)("inlineCode",{parentName:"p"},"Scala")," -> ",(0,i.yg)("inlineCode",{parentName:"p"},"Scala"),", whose interface looks like"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait Functor[F[_]]{\n  def map[A, B](f: A => B): F[A] => F[B]\n}\n")),(0,i.yg)("p",null,"or more commonly in the uncurried form "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait Functor[F[_]]{\n  def map[A, B](fa: F[A])(f: A => B): F[B]\n}\n")),(0,i.yg)("p",null,"properties are assumed for implementations"),(0,i.yg)("p",null,"there are some other interesting functors, for example"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait Invariant[F[_]]{\n    def imap[A, B](fa: F[A])(f: A => B)(g: B => A): F[B]\n}\n")),(0,i.yg)("p",null,"is an interface for functors from a Scala-",(0,i.yg)("a",{parentName:"p",href:"https://ncatlab.org/nlab/show/core"},"core"),", i.e. category of all Scala isomorphisms to Scala"),(0,i.yg)("p",null,"Notable endofunctor for any category is identity functor ",(0,i.yg)("inlineCode",{parentName:"p"},"Id")," such that "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"Id(a) = a\nmap{Id}(f) = f\n")),(0,i.yg)("p",null,"Also for any triple of categories C, D, E, having functors ",(0,i.yg)("inlineCode",{parentName:"p"},"F: D -> E"),"  and ",(0,i.yg)("inlineCode",{parentName:"p"},"G: C -> D")," we can define composition of functors"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"(F \u2218 G)(a) = F(G(a))\nmap{F \u2218 G}(f) = map{F}(map{G}(f))\n")),(0,i.yg)("p",null,(0,i.yg)("sup",{parentName:"p",id:"fnref-1"},(0,i.yg)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))),(0,i.yg)("h3",{id:"transformations"},"Transformations"),(0,i.yg)("p",null,"This section has a lot of unnecessary info, so you can skip it "),(0,i.yg)("p",null,"Having categories ",(0,i.yg)("inlineCode",{parentName:"p"},"C")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"D"),",  functors ",(0,i.yg)("inlineCode",{parentName:"p"},"F, G : C -> D"),",  natural transformation ",(0,i.yg)("inlineCode",{parentName:"p"},"\u0444 : F -> G")," "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"\u2200(a: C), F(a) -> G(a)\n")),(0,i.yg)("p",null,"together with property"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"naturality: \u2200(a, b: C), f: Hom(a, b), \u0444{b} \u2218 map{F}(f) = map{G}(f) \u2218 \u0444{a}\n")),(0,i.yg)("p",null,"in scala, if we are talking about endofunctors ",(0,i.yg)("inlineCode",{parentName:"p"},"Scala -> Scala")," we consider it having the following interface"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait FunctionK[F[_], G[_]]{ \n  def apply[A](fa: F[A]): G[A]\n}\n")),(0,i.yg)("p",null,"Still ",(0,i.yg)("inlineCode",{parentName:"p"},"F")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"G")," don't have to be Functors at all, so we can talk about just transformation (not natural) between type-constructors.",(0,i.yg)("sup",{parentName:"p",id:"fnref-2"},(0,i.yg)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))),(0,i.yg)("p",null,"For natural transformations, we can talk about identity and composition as well.\nFor any functor F, identity transformation is defined by"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"tid{F}{a} = id{F(a)}\n")),(0,i.yg)("p",null,"Moreover for categories ",(0,i.yg)("inlineCode",{parentName:"p"},"C"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"D")," and functors ",(0,i.yg)("inlineCode",{parentName:"p"},"F"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"G"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"H")," from C to D,  (vertical) composition of transformations ",(0,i.yg)("inlineCode",{parentName:"p"},"\u0444 : G -> H")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"\u0446 : F -> G")," is defined as"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"(\u0444 \u2218 \u0446){a} = \u0444{a} \u2218 \u0446{a}\n")),(0,i.yg)("p",null,"We can apply functor to the transformation at whole, supposing element-wise application, i.e. having categories\n",(0,i.yg)("inlineCode",{parentName:"p"},"C")," ,",(0,i.yg)("inlineCode",{parentName:"p"},"D"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"E")," and functors ",(0,i.yg)("inlineCode",{parentName:"p"},"F: C -> D"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"G: C -> D")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"H : D -> E"),", transformation ",(0,i.yg)("inlineCode",{parentName:"p"},"\u0444 : F -> G"),", we define new transformation from ",(0,i.yg)("inlineCode",{parentName:"p"},"H \u2218 F")," to ",(0,i.yg)("inlineCode",{parentName:"p"},"H \u2218 G")," as application ",(0,i.yg)("inlineCode",{parentName:"p"},"H")," to ",(0,i.yg)("inlineCode",{parentName:"p"},"\u0444")," : "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"H(\u0444){a} = map{H}(\u0444{a})\n")),(0,i.yg)("p",null,"Also we can apply transformation to a functor, i.e. having categories\n",(0,i.yg)("inlineCode",{parentName:"p"},"C")," ,",(0,i.yg)("inlineCode",{parentName:"p"},"D"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"E")," and functors ",(0,i.yg)("inlineCode",{parentName:"p"},"F: D -> E"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"G: D -> E")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"H : C -> D"),", transformation ",(0,i.yg)("inlineCode",{parentName:"p"},"\u0444 : F -> G"),", we define new transformation from ",(0,i.yg)("inlineCode",{parentName:"p"},"F \u2218 H")," to ",(0,i.yg)("inlineCode",{parentName:"p"},"G \u2218 H")," as an application of ",(0,i.yg)("inlineCode",{parentName:"p"},"\u0444")," to ",(0,i.yg)("inlineCode",{parentName:"p"},"H")," :"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"\u0444(H){a} = \u0444{H(a)}\n")),(0,i.yg)("p",null,"Generalizing that we can define the horizontal composition of transformations.\nFor any categories",(0,i.yg)("inlineCode",{parentName:"p"},"C, D, E")," , functors ",(0,i.yg)("inlineCode",{parentName:"p"},"F, G: D -> E")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"H, I : C -> D")," and transformations ",(0,i.yg)("inlineCode",{parentName:"p"},"\u0444: F -> G")," ",(0,i.yg)("inlineCode",{parentName:"p"},"\u0446: H -> I")," , horizontal composition\n",(0,i.yg)("inlineCode",{parentName:"p"},"\u0444 \u25cf \u0446 : F \u2218 H -> G \u2218 I")," is defined as "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"\u0444 \u25cf \u0446 {a} = \u0444{G(a)} \u2218 map{H}(\u0446{a})\n")),(0,i.yg)("p",null,"We can say that ",(0,i.yg)("inlineCode",{parentName:"p"},"\u0444 \u25cf \u0446 = \u0444(G) \u2218 H(\u0446)"),", or ",(0,i.yg)("inlineCode",{parentName:"p"},"\u0444(F) =  \u0444 \u25cf tid{F}")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"F(\u0444) = tid{F} \u25cf \u0444")),(0,i.yg)("h3",{id:"monad"},"Monad"),(0,i.yg)("p",null,"The traditional definition of a monad is the following: Monad ",(0,i.yg)("inlineCode",{parentName:"p"},"F")," in category ",(0,i.yg)("inlineCode",{parentName:"p"},"C")," is an endofunctor together with following natural transformations:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"\u03bd : Id -> F\n\u03bc : F \u2218 F -> F\n")),(0,i.yg)("p",null,"and properties"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"left-identity:  \u03bc \u2218 \u03bd(F) = tid{F}\nright-identity: \u03bc \u2218 F(\u03bd) = tid{F}\nassociativity:  \u03bc \u2218 \u03bc(F) = \u03bc \u2218 F(\u03bc)\n")),(0,i.yg)("p",null,"These definitions should lead us to the definition of Monad in ",(0,i.yg)("inlineCode",{parentName:"p"},"Scala")," like that"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait Monad[F[_]] extends Functor[F]{\n    def map[A, B](f: A => B): F[A] => F[B]\n    def pure[A](a: A): F[A]\n    def flatten[A](ffa: F[F[A]]): F[A]\n}\n")),(0,i.yg)("p",null,"It has three methods to define and seven properties to prove (functor-id, functor-compose, naturality of pure, naturality of ",(0,i.yg)("inlineCode",{parentName:"p"},"flatten"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"left-identity"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"right-identity")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"associativity"),")"),(0,i.yg)("p",null,"Meanwhile, even in general form in category theory, we can merge all the definitions into one and get a Hom-form of Monad definition"),(0,i.yg)("p",null,"So, monad ",(0,i.yg)("inlineCode",{parentName:"p"},"F")," in a category C is a function ",(0,i.yg)("inlineCode",{parentName:"p"},"C -> C")," (e.g. unary type-constructor in Scala), together with the following function families"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"pure: \u2200a: C, Hom(a, F(a))\nflatMap: \u2200(a, b: C), Hom(a, F(b)) -> Hom(F(a), F(b))\n")),(0,i.yg)("p",null,"together with the following laws"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"left-identity: \u2200(a, b: C), f: Hom(a, b), flatMap(f) \u2218 pure{b} = f\nright-identity: \u2200a: C, flatMap(pure{a}) = id{F(a)}\nassociativity: \u2200(a, b, c: C),f: Hom(b, F(c)), g: Hom(a, F(b)), flatMap(f) \u2218 flatMap(g) = flatMap(flatMap(f) \u2218 g)\n")),(0,i.yg)("p",null,"using these properties we can prove all seven properties for the original monad and vice versa. So it's just another definition for the same abstraction"),(0,i.yg)("p",null,"that immediately gives us another form for monad interface"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait Monad[F[_]]{\n    def pure[A](a: A): F[A]\n    def flatMap[A, B](f: A => F[B]): F[A] => F[B]\n}\n")),(0,i.yg)("p",null,"or in the uncurried version"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait Monad[F[_]]{\n    def pure[A](a: A): F[A]\n    def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]\n}\n")),(0,i.yg)("p",null,"Here we need to prove three well-known monad laws. Then functor laws, naturality restrictions, and original monad laws arise immediately."),(0,i.yg)("h2",{id:"bifunctors"},"Bifunctors"),(0,i.yg)("h3",{id:"product-of-categories"},"Product of categories"),(0,i.yg)("p",null,"For any categories ",(0,i.yg)("inlineCode",{parentName:"p"},"C")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"D")," we can define their product ",(0,i.yg)("inlineCode",{parentName:"p"},"C \xd7 D")," as a category, which objects are pairs ",(0,i.yg)("inlineCode",{parentName:"p"},"(a, x)")," where ",(0,i.yg)("inlineCode",{parentName:"p"},"a")," is an object of ",(0,i.yg)("inlineCode",{parentName:"p"},"C")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"x")," is an object of ",(0,i.yg)("inlineCode",{parentName:"p"},"D"),"\nThen ",(0,i.yg)("inlineCode",{parentName:"p"},"Hom((a, x), (b, y))")," is a ",(0,i.yg)("inlineCode",{parentName:"p"},"Hom(a, b) \xd7 Hom(x, y)"),", i.e. set of pairs ",(0,i.yg)("inlineCode",{parentName:"p"},"(f, u)")," where ",(0,i.yg)("inlineCode",{parentName:"p"},"f")," is an element of ",(0,i.yg)("inlineCode",{parentName:"p"},"Hom(a, b)")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"u")," is an element of ",(0,i.yg)("inlineCode",{parentName:"p"},"Hom(x, y)")),(0,i.yg)("p",null,"Rest of the structure defined as follows"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"id{(a, x)} = (id{a}, id{x})\n(f, u) \u2218 (g, v) = (f \u2218 g, u \u2218 v)\n")),(0,i.yg)("p",null,"And properties are easy to prove."),(0,i.yg)("h3",{id:"bifunctor"},"Bifunctor"),(0,i.yg)("p",null,'Bifunctor is just a word meaning "functor from the product of categories", so bifunctor ',(0,i.yg)("inlineCode",{parentName:"p"},"C \xd7 D -> E")," is just a functor ",(0,i.yg)("inlineCode",{parentName:"p"},"C \xd7 D -> E")," "),(0,i.yg)("p",null,"Technically that means that we have a binary function on objects and\nmapping function, that mapping couple of functions into a single one."),(0,i.yg)("p",null,"So bifunctor ",(0,i.yg)("inlineCode",{parentName:"p"},"Scala \xd7 Scala -> Scala")," would have following interface "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait Bifunctor[F[_, _]]{\n    def bimap[A, B, C, D](f: A => B, g: C => D): F[A, B] => F[C, D]\n}\n")),(0,i.yg)("p",null,"One notable property of bifunctors is orthogonality of mappings, meaning"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"(f, id) \u2218 (id, g) = (f \u2218 id, id \u2218 g) = (f, g) = (id \u2218 f, g \u2218 id) = \n    (id, g) \u2218 (f, id)\n")),(0,i.yg)("p",null,"and for bifunctor ",(0,i.yg)("inlineCode",{parentName:"p"},"F")," it would mean that "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"map{F}(f, id) \u2218 map{F}(id, g) = map{F}(id, g) \u2218 map{F}(f, id)\n")),(0,i.yg)("p",null,"Which looks like some form of commutativity, but is not since ",(0,i.yg)("inlineCode",{parentName:"p"},"id"),"s have different implicit indices"),(0,i.yg)("p",null,"But it allows to define bifunctor in the following form"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait Bifunctor[F[_, _]]{\n    def lmap[A, B, C](f: A => B): F[A, C] => F[B, C]\n    def rmap[A, B, C](f: A => B): F[C, A] => F[C, A]\n}\n")),(0,i.yg)("p",null,"So we definitely may split any mappings to left and right components"),(0,i.yg)("h3",{id:"bifunctor-monad"},"Bifunctor monad"),(0,i.yg)("p",null,"So what is a monad which is also bifunctor? It should be an endofunctor from a product of some categories, implying that it's a functor which results also in a product of these categories,"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"pure: \u2200a: C, x: D, Hom((a, x), F(a, x))\nflatMap: \u2200(a, b: C), (x, y: D), Hom((a, x), F(b, y)) -> Hom(F(a, x), F(b, y))\n")),(0,i.yg)("p",null,"But here we must remember that F is a function to a pair of objects.",(0,i.yg)("br",{parentName:"p"}),"\n","How can we represent such thing on scala types?",(0,i.yg)("br",{parentName:"p"}),"\n","We can immediately think of any function resulting in a pair as a pair of functions, producing corresponding elements of pair.\nMeaning that ",(0,i.yg)("inlineCode",{parentName:"p"},"F: A -> B \xd7 C")," can be represented ",(0,i.yg)("inlineCode",{parentName:"p"},"F_1: A -> B")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"F_2: A -> C")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"F(a) = (F_1(a), F_2(a))"),".",(0,i.yg)("br",{parentName:"p"}),"\n","So a binary function from types to a pair of types we can represent as a pair of type constructors.\nSame trick will work for components of ",(0,i.yg)("inlineCode",{parentName:"p"},"pure")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"flatMap")," : instead of tuple of functions as a result we define two different methods for each component\nThere for a bifunctor monad\n",(0,i.yg)("inlineCode",{parentName:"p"},"Scala \xd7 Scala -> Scala \xd7 Scala")," would look as "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait BiMonad[L[_, _], R[_, _]]{\n    def pureLeft[A, B](a: A): L[A, B]\n    def pureRight[A, B](b: B): R[A, B]\n    def flatMapLeft[A, B, C, D](fl: A => L[C, D], fr: B => R[C, D]): L[A, B] => L[C, D]\n    def flatMapRight[A, B, C, D](fl: A => L[C, D], fr: B => R[C, D]): R[A, B] => R[C, D]\n}\n")),(0,i.yg)("p",null,"We can easily uncurry that and define bifunctors for both ",(0,i.yg)("inlineCode",{parentName:"p"},"L")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"R")," using such definitions."),(0,i.yg)("h3",{id:"twin-monad"},"Twin monad"),(0,i.yg)("p",null,"Such definitions are still unsettling. It is hard to imagine how it could be useful having two different type-constructors. So the most obvious way of narrowing our definition is requiring that\n",(0,i.yg)("inlineCode",{parentName:"p"},"R = L"),", then our definitions of ",(0,i.yg)("inlineCode",{parentName:"p"},"flatMapLeft")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"flatMapRight")," become identical and can be further merged into one method."),(0,i.yg)("p",null,"So now we with just three methods for which we can imagine fancy names."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"pureLeft")," we will call ",(0,i.yg)("inlineCode",{parentName:"p"},"raise")," as it was raising errors\n",(0,i.yg)("inlineCode",{parentName:"p"},"pureRight")," we will call ",(0,i.yg)("inlineCode",{parentName:"p"},"pure")," since right side we decide to be the ",(0,i.yg)("em",{parentName:"p"},"right side"),"\nand merged ",(0,i.yg)("inlineCode",{parentName:"p"},"flatMap")," we will call ",(0,i.yg)("inlineCode",{parentName:"p"},"foldWith")," since it provides a way to continue from both success and error and has some resemblance with ",(0,i.yg)("inlineCode",{parentName:"p"},"fold")," method on well-known bifunctors like ",(0,i.yg)("inlineCode",{parentName:"p"},"Either")," now we get our glorious and uncurried"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"trait TwinMonad[F[_, _]]{\n    def raise[A, B](a: A): F[A, B]\n    def success[A, B](b: B): F[A, B]\n    def foldWith[A, B, C, D](fab: F[A, B])(f: A => F[C, D], g: B => F[C, D]): F[C, D]\n}\n")),(0,i.yg)("p",null,"Following the Monad laws, we derive 4 fundamental laws for the TwinMonad",(0,i.yg)("sup",{parentName:"p",id:"fnref-3"},(0,i.yg)("a",{parentName:"sup",href:"#fn-3",className:"footnote-ref"},"3"))),(0,i.yg)("p",null,"In the following code all the parameters (types and values) implied to be universally quantifined (",(0,i.yg)("em",{parentName:"p"},"for all"),") , and the resulting equality type ",(0,i.yg)("inlineCode",{parentName:"p"},":=:")," - is the required property"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"    def raiseFold[E1, A1, E2, A2](e: E1)(f: E1 => F[E2, A2])(g: A1 => F[E2, A2]) : \n        foldWith(raise(e))(f, g) :=: f(e)\n    \n    def successFold[E1, A1, E2, A2](a: A1)(f: E1 => F[E2, A2])(g: A1 => F[E2, A2]) : \n        foldWith(raise(e))(f, g) :=: g(a)\n\n    def foldPure[E, A](fea: F[E, A]) : foldWith(fea)(raise)(success) :=: fea\n\n    def foldAssoc[E1, A1, E2, A2, E3, A3](\n        fea: F[E, A]\n    )(\n        f1: E1 => F[E2, A2], g1: A1 => F[E2, A2]\n    )(\n        f2: E2 => F[E3, A3], g2: A2 => F[E3, A3]\n    ): foldWith(foldWith(fea)(f1, g1))(f1, g1) :=: foldWith(fea)(e => foldWith(f1(e))(f2, g2), a => foldWith(g1(a))(f2, g2qq)\n")),(0,i.yg)("h3",{id:"symmetry"},"Symmetry"),(0,i.yg)("p",null,"so right from this, we may define the following method"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"def swap[E, A](fea: F[E, A]): F[A, E] = foldWith(fea)(success, raise)\n")),(0,i.yg)("p",null,"and directly from the laws we can prove following lemmas"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"def swapInvolutive[E, A](fea: F[E, A]): swap(swap(fea)) :=: fea\ndef swapRaise[E, A](e: E): swap(raise(e)) :=: success(e)\ndef swapSuccess[E, A](a: A): swap(success(a)) :=: raise(e)\ndef swap-fold[E1, A1, E2, A2](fea: F[E1, A1])(f: E1 => F[E2, A2])(g: A1 => F[E2, A2]) : \n    foldWith(swap(fea)(g, f) = foldWith(fea)(f, g)\n")),(0,i.yg)("p",null,"So our monad has a powerful quality of symmetry. We require that monad treats errors and successes equally, so we can switch between them whenever we want.\nAll types that can't satisfy this property we reject.\nMoreover, in all the abstractions on top of ",(0,i.yg)("inlineCode",{parentName:"p"},"TwinMonad"),", we'll search for the same symmetry, trying not to think of one binding channel more than of another.\nThat will help us to find correct shapes in the binary monad universe."),(0,i.yg)("h3",{id:"stack-safety"},"Stack safety"),(0,i.yg)("p",null,"To restore the same stack-safe qualities that are already in the ",(0,i.yg)("inlineCode",{parentName:"p"},"cats")," we add another iterative form of ",(0,i.yg)("inlineCode",{parentName:"p"},"foldWith")," called ",(0,i.yg)("inlineCode",{parentName:"p"},"foldRec"),".\n",(0,i.yg)("inlineCode",{parentName:"p"},"def foldRec[E, A, X, B](init: Either[E, A])(step: Either[E, A] => F[Either[E, X], Either[A, B]]): F[X, B]")," - here ",(0,i.yg)("inlineCode",{parentName:"p"},"E")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," are type parameters for the intermediate results, while we have ",(0,i.yg)("inlineCode",{parentName:"p"},"Left(e: E)")," on the error channel or ",(0,i.yg)("inlineCode",{parentName:"p"},"Left(a: A)")," on the right channel the iteration continues. As soon as we reached ",(0,i.yg)("inlineCode",{parentName:"p"},"Right(x :X)")," on the left or ",(0,i.yg)("inlineCode",{parentName:"p"},"Right(b: B)")," on the right, we must stop, finalizing the result. "),(0,i.yg)("p",null,"Resulting bifunctor brother of ",(0,i.yg)("inlineCode",{parentName:"p"},"cats.Monad")," we call ",(0,i.yg)("inlineCode",{parentName:"p"},"Bind")," which I feel is nice for two reasons:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"It starts with ",(0,i.yg)("inlineCode",{parentName:"li"},"Bi")," so it's easy to recall it when you are thinking about bifunctors"),(0,i.yg)("li",{parentName:"ol"},"Its name resembles is a common alias for the ",(0,i.yg)("inlineCode",{parentName:"li"},"flatMap")," method, so it's easy to recall it as a ",(0,i.yg)("inlineCode",{parentName:"li"},"Monad"))),(0,i.yg)("div",{className:"footnotes"},(0,i.yg)("hr",{parentName:"div"}),(0,i.yg)("ol",{parentName:"div"},(0,i.yg)("li",{parentName:"ol",id:"fn-1"},"We may consider a category of categories, where functors are morphisms. Such functors would play the role of an identity morphism and composition here",(0,i.yg)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")),(0,i.yg)("li",{parentName:"ol",id:"fn-2"},"Note that if we consider the category of scala types, where all ",(0,i.yg)("inlineCode",{parentName:"li"},"Hom"),"s are empty, any type constructor there would be a functor, and any transformation would be natural.",(0,i.yg)("a",{parentName:"li",href:"#fnref-2",className:"footnote-backref"},"\u21a9")),(0,i.yg)("li",{parentName:"ol",id:"fn-3"},"These and others proofs can be found in ",(0,i.yg)("a",{parentName:"li",href:"https://github.com/Odomontois/Tincat/blob/master/src/Functor/Monad.ard"},"our Arend repository dedicated to Category Theory"),(0,i.yg)("a",{parentName:"li",href:"#fnref-3",className:"footnote-backref"},"\u21a9")))))}c.isMDXComponent=!0}}]);