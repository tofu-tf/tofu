"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8673],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>g});var a=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),m=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=m(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=m(n),d=r,g=c["".concat(l,".").concat(d)]||c[d]||u[d]||s;return n?a.createElement(g,o(o({ref:t},p),{},{components:n})):a.createElement(g,o({ref:t},p))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[c]="string"==typeof e?e:r,o[1]=i;for(var m=2;m<s;m++)o[m]=n[m];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8116:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>g,frontMatter:()=>i,metadata:()=>m,toc:()=>c});var a=n(8168),r=n(8587),s=(n(6540),n(5680)),o=["components"],i={id:"streams",title:"Streams"},l="Streams",m={unversionedId:"streams",id:"streams",title:"Streams",description:"Functional streaming effects like fs2 had become a very handy tool for modeling streaming pipelines.",source:"@site/../docs/streams.md",sourceDirName:".",slug:"/streams",permalink:"/tofu/docs/streams",draft:!1,tags:[],version:"current",lastUpdatedBy:"Vadim Chelyshov",lastUpdatedAt:1742978697,formattedLastUpdatedAt:"Mar 26, 2025",frontMatter:{id:"streams",title:"Streams"},sidebar:"docs",previous:{title:"Memo",permalink:"/tofu/docs/memo"}},p={},c=[{value:"Type classes",id:"type-classes",level:2},{value:"Emits",id:"emits",level:3},{value:"Evals",id:"evals",level:3},{value:"Chunks",id:"chunks",level:3},{value:"Temporal",id:"temporal",level:3},{value:"Merge",id:"merge",level:3},{value:"ParFlatten",id:"parflatten",level:3},{value:"Region",id:"region",level:3},{value:"Pace",id:"pace",level:3},{value:"Broadcast",id:"broadcast",level:3},{value:"Compile",id:"compile",level:3},{value:"Abstracting from legacy API",id:"abstracting-from-legacy-api",level:2},{value:"Apps built on Tofu Streams",id:"apps-built-on-tofu-streams",level:2}],u={toc:c},d="wrapper";function g(e){var t=e.components,n=(0,r.A)(e,o);return(0,s.yg)(d,(0,a.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.yg)("h1",{id:"streams"},"Streams"),(0,s.yg)("p",null,"Functional streaming effects like ",(0,s.yg)("inlineCode",{parentName:"p"},"fs2")," had become a very handy tool for modeling streaming pipelines.\nNevertheless, such libraries have several drawbacks heavily affecting user code  and making their usage less convenient.\nTofu Streams offers a set of type-classes allowing to abstract functional streaming effects in a TF way."),(0,s.yg)("h2",{id:"type-classes"},"Type classes"),(0,s.yg)("h3",{id:"emits"},"Emits"),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"Emits")," lets you emit some collection of elements into a stream:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import cats.instances.list._\nimport tofu.streams.Emits\nimport tofu.syntax.streams.emits._\n\ndef names[F[_]: Emits]: F[String] = {\n  val xs = List("Sandy", "Sally", "Susan")\n  emits(xs)\n}\n')),(0,s.yg)("h3",{id:"evals"},"Evals"),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"Evals")," allows you to evaluate some other effect inside a streaming effect.\nIn the example below ",(0,s.yg)("inlineCode",{parentName:"p"},"Stream[IO, *]")," can be put in place of ",(0,s.yg)("inlineCode",{parentName:"p"},"F[_]")," and ",(0,s.yg)("inlineCode",{parentName:"p"},"IO")," in place of ",(0,s.yg)("inlineCode",{parentName:"p"},"G[_]"),". "),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import cats.Monad\nimport tofu.streams.Evals\nimport tofu.syntax.monadic._\nimport tofu.syntax.streams.evals._\n\ntrait Metrics[F[_]] {\n  def send(key: String, value: Long): F[Unit]\n}\n\ntrait Logging[F[_]] {\n  def info(msg: String): F[Unit]\n}\n\ncase class Bid(amount: Long, ticker: String)\n\ndef stats[F[_]: Monad: Evals[*[_], G], G[_]](metrics: Metrics[G], logs: Logging[G]): F[Bid] => F[Unit] =\n  in => eval(logs.info("Sending stats")) >> in.evalMap(bid => metrics.send(s"bid.${bid.ticker}.amount", bid.amount))\n')),(0,s.yg)("h3",{id:"chunks"},"Chunks"),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"Chunks")," exposes an API for working with internal structure of a streaming effect - chunks.\nSupposing we want to process a stream of elements in batches for performance reasons:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},"import cats.Foldable\nimport cats.syntax.foldable._\nimport tofu.streams._\nimport tofu.syntax.streams.evals._\nimport tofu.syntax.streams.chunks._\n\ncase class Order(baseAsset: String, quoteAsset: String, amount: Long, price: Long, ownerId: Long)\n\ntrait OrderBook[F[_]] {\n  def add(orders: List[Order]): F[Unit]\n}\n\ndef batchProcess[\n  F[_]: Chunks[*[_], C]: Evals[*[_], G],\n  G[_],\n  C[_]: Foldable\n](orderBook: OrderBook[G]): F[Order] => F[Unit] =\n  _.chunks.evalMap(orders => orderBook.add(orders.toList))\n")),(0,s.yg)("h3",{id:"temporal"},"Temporal"),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"Temporal")," is capable of taking temporal slices of a stream.\nConsider a modified version of ",(0,s.yg)("inlineCode",{parentName:"p"},"batchProcess")," from the previous example for ",(0,s.yg)("inlineCode",{parentName:"p"},"Chunks"),"\nworking with chunks either accumulated withing 5 seconds or reached the size of 1000 elements:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},"import cats.Foldable\nimport cats.syntax.foldable._\nimport tofu.streams._\nimport tofu.syntax.streams.evals._\nimport tofu.syntax.streams.temporal._\n\nimport scala.concurrent.duration._\n\ncase class Order(baseAsset: String, quoteAsset: String, amount: Long, price: Long, ownerId: Long)\n\ntrait OrderBook[F[_]] {\n  def add(orders: List[Order]): F[Unit]\n}\n\ndef batchProcess[\n  F[_]: Temporal[*[_], C]: Evals[*[_], G],\n  G[_],\n  C[_]: Foldable\n](orderBook: OrderBook[G]): F[Order] => F[Unit] =\n  _.groupWithin(1000, 5.seconds).evalMap(orders => orderBook.add(orders.toList))\n")),(0,s.yg)("h3",{id:"merge"},"Merge"),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"Merge")," allows you to interleave two input streams non-deterministically:\nIn the example below we want ",(0,s.yg)("inlineCode",{parentName:"p"},"printFakeOfTrue")," to continually print either fake or true facts pulled from\ntwo different sources respectively:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},"import tofu.common.Console\nimport tofu.streams._\nimport tofu.syntax.streams.evals._\nimport tofu.syntax.streams.merge._\nimport tofu.syntax.console._\n\ncase class Fact(value: String)\n\ntrait Facts[F[_]] {\n  def stream: F[Fact]\n}\n\ndef printFakeOfTrue[F[_]: Merge: Evals[*[_], G], G[_]: Console](\n  fakes: Facts[F],\n  truth: Facts[F]\n): F[Unit] =\n   (fakes.stream merge truth.stream).evalMap(fact => putStrLn(fact.value))\n")),(0,s.yg)("h3",{id:"parflatten"},"ParFlatten"),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"ParFlatten")," allows you to run multiple streams inside an outer stream simultaneously merging\ntheir outputs into a single stream non-deterministically.\nIn the example below we want to run multiple processes concurrently:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},"import cats.instances.list._\nimport tofu.common.Console\nimport tofu.streams._\nimport tofu.syntax.streams.emits._\nimport tofu.syntax.streams.parFlatten._\nimport tofu.syntax.console._\n\ncase class SensorData()\n\ntrait Sensor[F[_]] {\n  def run: F[SensorData]\n}\n\ndef readDataFromAllSensors[F[_]: ParFlatten: Emits](sensors: List[Sensor[F]]): F[SensorData] =\n  emits(sensors.map(_.run)).parFlattenUnbounded\n")),(0,s.yg)("h3",{id:"region"},"Region"),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"Region")," is responsible for managing resources withing a stream.\nIn the following example let's imagine we want ",(0,s.yg)("inlineCode",{parentName:"p"},"ping"),' to acquire connection and then send "PING"\nmessage continually until it is interrupted.'),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import cats.{Applicative, Defer, Monad, SemigroupK}\nimport tofu.streams._\nimport tofu.syntax.streams.region._\nimport tofu.syntax.streams.evals._\nimport tofu.syntax.streams.combineK._\nimport tofu.syntax.monadic._\n\ntrait Socket[F[_]] {\n  def write(bytes: Array[Byte]): F[Unit]\n  def close: F[Unit]\n}\n\ntrait MakeSocket[F[_]] {\n  def open[I[_]]: I[Socket[F]]\n}\n\ndef ping[\n  F[_]: Monad: SemigroupK: Defer: Region[*[_], G, E]: Evals[*[_], G],\n  G[_],\n  E\n](socket: MakeSocket[G]): F[Unit] =\n  region(socket.open[G])(_.close).flatMap { sock =>\n    // `.repeat` is a special syntax from `tofu.syntax.streams.combineK` based on `SemigroupK` and `Defer`.\n    eval(sock.write("PING".getBytes)).repeat\n  }\n')),(0,s.yg)("h3",{id:"pace"},"Pace"),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"Pace")," lets you regulate the pace of a stream.\nLooking at the ",(0,s.yg)("inlineCode",{parentName:"p"},"ping")," implementation from the previous example you might have\nadmitted that we don't need to send pings at the maximum possible rate.\nLet's throttle it down to 1 ping at 10 seconds:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},'import cats.{Applicative, Defer, Monad, SemigroupK}\nimport tofu.streams._\nimport tofu.syntax.streams.region._\nimport tofu.syntax.streams.evals._\nimport tofu.syntax.streams.combineK._\nimport tofu.syntax.streams.pace._\nimport tofu.syntax.monadic._\n\nimport scala.concurrent.duration._\n\ntrait Socket[F[_]] {\n  def write(bytes: Array[Byte]): F[Unit]\n  def close: F[Unit]\n}\n\ntrait MakeSocket[F[_]] {\n  def open[I[_]]: I[Socket[F]]\n}\n\ndef ping[\n  F[_]: Monad: SemigroupK: Defer: Region[*[_], G, E]: Evals[*[_], G]: Pace,\n  G[_],\n  E\n](socket: MakeSocket[G]): F[Unit] =\n  region(socket.open[G])(_.close).flatMap { sock =>\n    eval(sock.write("PING".getBytes)).repeat.throttled(10.seconds)\n  }\n')),(0,s.yg)("h3",{id:"broadcast"},"Broadcast"),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"Broadcast")," makes it possible to pipe outputs of a stream to several processors ",(0,s.yg)("inlineCode",{parentName:"p"},"F[A] => F[B]"),"\nsimultaneously."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},"import tofu.streams.Broadcast\nimport tofu.syntax.streams.broadcast._\n\ncase class Order()\n\ntrait Stats[F[_]] {\n  def process: F[Order] => F[Unit]\n}\n\ntrait Shipping[F[_]] {\n  def process: F[Order] => F[Unit]\n}\n\ndef processOrders[F[_]: Broadcast](shipping: Shipping[F], stats: Stats[F]): F[Order] => F[Unit] =\n  _.broadcast(shipping.process, stats.process)\n")),(0,s.yg)("h3",{id:"compile"},"Compile"),(0,s.yg)("p",null,(0,s.yg)("inlineCode",{parentName:"p"},"Compile")," provides methods for materialization of a stream in several ways:"),(0,s.yg)("p",null,"First use case is to simply project a process described in terms of a streaming\neffect into a regular effect like ",(0,s.yg)("inlineCode",{parentName:"p"},"IO")," ignoring the result:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},"import tofu.streams._\nimport tofu.syntax.streams.compile._\n\ntrait Cats[F[_]] {\n  def print: F[Unit] // prints various cats into a console continually\n}\n\ndef runCatsPrinter[F[_]: Compile[*[_], G], G[_]](cats: Cats[F]): G[Unit] =\n   cats.print.drain\n")),(0,s.yg)("p",null,"In some other cases we might want to materialize a stream into a collection of elements:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},"import tofu.streams._\nimport tofu.syntax.streams.compile._\n\ncase class Cat(name: String)\n\ntrait Cats[F[_]] {\n  def emit: F[Cat] // emit various cats continually\n}\n\ndef catsList[F[_]: Compile[*[_], G], G[_]](n: Int)(cats: Cats[F]): G[LazyList[Cat]] =\n   cats.emit.to[LazyList]\n")),(0,s.yg)("h2",{id:"abstracting-from-legacy-api"},"Abstracting from legacy API"),(0,s.yg)("p",null,"In real applications we usually would have to deal with API exposing concrete stream datatype.\nIn order to abstract from it all we need is ",(0,s.yg)("inlineCode",{parentName:"p"},"type LiftStream[S[_], F[_]] = Lift[Stream[F, *], S]"),"."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-scala"},"import cats.tagless.FunctorK\nimport fs2.Stream\nimport derevo.derive\nimport tofu.higherKind.derived.representableK\nimport tofu.fs2.LiftStream\n\ncase class Event(name: String)\n\n@derive(representableK)\ntrait Consumer[F[_]] {\n  def eventStream: F[Event]\n}\n\nobject Consumer {\n\n  // smart-constructor for `Consumer` lifting `Consumer[Stream[G, *]]` into `Consumer[F]` \n  // parametrized with an abstract streaming effect `F`.\n  def make[F[_]: LiftStream[*[_], G], G[_]]: Consumer[F] =\n    FunctorK[Consumer].mapK(new Impl[G])(LiftStream[F, G].liftF)\n\n  // concrete implementation of consumer parametrized with `Stream[F, *]`\n  final class Impl[F[_]] extends Consumer[Stream[F, *]] {\n    def eventStream: Stream[F, Event] = ??? // implementation based on a legacy API exposing `Stream` datatype.\n  }\n}\n")),(0,s.yg)("h2",{id:"apps-built-on-tofu-streams"},"Apps built on Tofu Streams"),(0,s.yg)("p",null,(0,s.yg)("a",{parentName:"p",href:"https://github.com/oskin1/binance-aggregator"},"binance-aggregator")))}g.isMDXComponent=!0}}]);