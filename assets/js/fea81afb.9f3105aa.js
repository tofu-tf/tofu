"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1833],{5680:(e,n,a)=>{a.d(n,{xA:()=>p,yg:()=>m});var t=a(6540);function o(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),a.push.apply(a,t)}return a}function g(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach(function(n){o(e,n,a[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))})}return e}function r(e,n){if(null==e)return{};var a,t,o=function(e,n){if(null==e)return{};var a,t,o={},i=Object.keys(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||(o[a]=e[a]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=t.createContext({}),s=function(e){var n=t.useContext(l),a=n;return e&&(a="function"==typeof e?e(n):g(g({},n),e)),a},p=function(e){var n=s(e.components);return t.createElement(l.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef(function(e,n){var a=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),c=s(a),u=o,m=c["".concat(l,".").concat(u)]||c[u]||d[u]||i;return a?t.createElement(m,g(g({ref:n},p),{},{components:a})):t.createElement(m,g({ref:n},p))});function m(e,n){var a=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=a.length,g=new Array(i);g[0]=u;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r[c]="string"==typeof e?e:o,g[1]=r;for(var s=2;s<i;s++)g[s]=a[s];return t.createElement.apply(null,g)}return t.createElement.apply(null,a)}u.displayName="MDXCreateElement"},6443:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var t=a(8168),o=a(8587),i=(a(6540),a(5680)),g=["components"],r={id:"logging.old",title:"Logging"},l="Warning",s={unversionedId:"logging.old",id:"logging.old",title:"Logging",description:"This page is obsolete. Head on to the new docs on logging.",source:"@site/../docs/logging.old.md",sourceDirName:".",slug:"/logging.old",permalink:"/tofu/docs/logging.old",draft:!1,tags:[],version:"current",lastUpdatedBy:"\u0410\u043d\u0442\u043e\u043d \u0412\u043e\u0438\u0306\u0446\u0438\u0448\u0435\u0432\u0441\u043a\u0438\u0438\u0306",lastUpdatedAt:1631546433,formattedLastUpdatedAt:"Sep 13, 2021",frontMatter:{id:"logging.old",title:"Logging"}},p={},c=[{value:"Installation",id:"installation",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Preface",id:"preface",level:3},{value:"What&#39;s wrong (and how to fix that)?",id:"whats-wrong-and-how-to-fix-that",level:3},{value:"Representation",id:"representation",level:2},{value:"Loggable example",id:"loggable-example",level:3},{value:"Loggable derivation",id:"loggable-derivation",level:2},{value:"Configuring Loggable generation",id:"configuring-loggable-generation",level:3},{value:"Creation",id:"creation",level:2},{value:"Plain <code>Logging</code>",id:"plain-logging",level:3},{value:"Typesafe <code>ServiceLogging</code>",id:"typesafe-servicelogging",level:3},{value:"Ways to create Logs",id:"ways-to-create-logs",level:3},{value:"Context logging",id:"context-logging",level:2},{value:"Example",id:"example",level:3},{value:"Business Logic",id:"business-logic",level:4},{value:"Server",id:"server",level:4},{value:"Loggable derivation",id:"loggable-derivation-1",level:4},{value:"Running",id:"running",level:4},{value:"Syntax extensions",id:"syntax-extensions",level:2},{value:"Integration with logs4cats",id:"integration-with-logs4cats",level:2}],d={toc:c},u="wrapper";function m(e){var n=e.components,a=(0,o.A)(e,g);return(0,i.yg)(u,(0,t.A)({},d,a,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"warning"},"Warning"),(0,i.yg)("p",null,"This page is obsolete. Head on to the ",(0,i.yg)("a",{parentName:"p",href:"/tofu/docs/tofu.logging.home"},"new docs on logging"),"."),(0,i.yg)("h2",{id:"installation"},"Installation"),(0,i.yg)("p",null,"Logging are available as a separate project\n",(0,i.yg)("inlineCode",{parentName:"p"},'"tf.tofu" %% "tofu-logging" % tofu-version')),(0,i.yg)("h2",{id:"motivation"},"Motivation"),(0,i.yg)("h3",{id:"preface"},"Preface"),(0,i.yg)("p",null,"Almost every application nowadays does logging, whether it is logging of business events, history of some state of\napplication or even debug record sequences. We log to files, distributed systems, standard outputs of OSes, and we got\nused to it so much it seems simple to us. Many existing libraries provide many ways of logging from your application's\ncode, either automatic or manual."),(0,i.yg)("h3",{id:"whats-wrong-and-how-to-fix-that"},"What's wrong (and how to fix that)?"),(0,i.yg)("p",null,"First, logging is, in fact, a side effect. Whether we log anything to standard output or a file \u2014 it's an interaction\nwith the outside world ('outside' relative to our program). Thus, logging as a process can be represented as an effect\nand operations - as an algebra.",(0,i.yg)("br",{parentName:"p"}),"\n","Second, logging itself seems easy, but stuff around it - not so much. MDC, contexts, structured logging - all these\nthings are very helpful on a day-to-day basis, allowing us to read and write our logs, making them clean, comprehensible\nand useful for many purposes. But there are few simple ways to provide all this functionality without bleeding and\nscreaming from seeing over-engineered solutions.",(0,i.yg)("br",{parentName:"p"}),"\n","Tofu offers an easy and understandable abstraction over logging (it's even named like this!) but keeping in mind that\nlogging is an effect that can be composed.",(0,i.yg)("br",{parentName:"p"}),"\n","It looks very similar to interfaces we all are used to (from SLF4J and other logging libraries and facades), introducing\nsome new concepts:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala:reset"},"import tofu.logging.LoggedValue\n\ntrait Logging[F[_]] {\n  def trace(message: String, values: LoggedValue*): F[Unit]\n\n  def debug(message: String, values: LoggedValue*): F[Unit]\n\n  def info(message: String, values: LoggedValue*): F[Unit]\n\n  def warn(message: String, values: LoggedValue*): F[Unit]\n\n  def error(message: String, values: LoggedValue*): F[Unit]\n}\n\n")),(0,i.yg)("p",null,"Basically, that's the main user API you can interact with throughout your code. It resembles well-known solutions,\nkeeping in mind that logging is an effect, though introducing the concept of ",(0,i.yg)("inlineCode",{parentName:"p"},"LoggedValue"),"."),(0,i.yg)("h2",{id:"representation"},"Representation"),(0,i.yg)("p",null,"To represent a value in logs we use a concept of ",(0,i.yg)("inlineCode",{parentName:"p"},"Loggable")," (it's a typeclass). It describes how a value of some type\ncan be logged, both as a string representation in log message and as a component of structured logging. Given an\ninstance of ",(0,i.yg)("inlineCode",{parentName:"p"},"Loggable")," for a type, a value of the type can be converted into the final internal representation\ncalled ",(0,i.yg)("inlineCode",{parentName:"p"},"LoggedValue")," and thus logged in a way that you provided.",(0,i.yg)("br",{parentName:"p"}),"\n","There are multiple predefined ways to create an instance of ",(0,i.yg)("inlineCode",{parentName:"p"},"Loggable"),", many of them can be found\nin ",(0,i.yg)("inlineCode",{parentName:"p"},"tofu.logging.Loggable")," object:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Loggable.empty")," for no-op logging of value"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Loggable.show")," for using ",(0,i.yg)("inlineCode",{parentName:"li"},"cats.Show")," instance as string representaion"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Loggable.either")," for logging either of ",(0,i.yg)("inlineCode",{parentName:"li"},"A")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"B")),(0,i.yg)("li",{parentName:"ul"},"provided instances for all primitive types, as well as stdlib's collections and collections from Cats"),(0,i.yg)("li",{parentName:"ul"},"java.time.* instances")),(0,i.yg)("p",null,"Of course, you can describe your ",(0,i.yg)("inlineCode",{parentName:"p"},"Loggable")," instance yourself by extending existing traits that pre-implement some\nfunctionality:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"DictLoggable")," for multi-field objects"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"ToStringLoggable")," for using ",(0,i.yg)("inlineCode",{parentName:"li"},".toString")," for logging"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"HideLoggable")," to exclude value from logging")),(0,i.yg)("h3",{id:"loggable-example"},"Loggable example"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala:reset"},'import tofu.logging._\nimport cats.syntax.semigroup._\n\ncase class User(name: String, surname: String)\n\nimplicit val userLoggable = new DictLoggable[User] {\n  override def fields[I, V, R, S](a: User, i: I)(implicit r: LogRenderer[I, V, R, S]): R = {\n    r.addString("name", a.name, i) |+| r.addString("surname", a.surname, i)\n  }\n\n  override def logShow(a: User): String = s"name = ${a.name}, surname = ${a.surname}"\n}\n')),(0,i.yg)("p",null,"Let's take a look at this example.",(0,i.yg)("br",{parentName:"p"}),"\n","First, we define a loggable for our ",(0,i.yg)("inlineCode",{parentName:"p"},"User")," class as a ",(0,i.yg)("inlineCode",{parentName:"p"},"DictLoggable")," which means that we want to log it as a multi-field\nobject with structure.",(0,i.yg)("br",{parentName:"p"}),"\n","Second, we define two methods that describe how ",(0,i.yg)("inlineCode",{parentName:"p"},"User")," should be logged:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"fields"),", that represents ",(0,i.yg)("inlineCode",{parentName:"li"},"User")," as a structure, containing two fields with their respective names and values"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"logShow"),", that represents ",(0,i.yg)("inlineCode",{parentName:"li"},"User")," as a string in a log message")),(0,i.yg)("h2",{id:"loggable-derivation"},"Loggable derivation"),(0,i.yg)("p",null,"a\nTofu has integration with ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/tofu-tf/derevo"},"derevo")," library. It allows you to easily generate\ninstances of ",(0,i.yg)("inlineCode",{parentName:"p"},"Loggable[YourClass]")," for case classes or ADTs:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala:reset"},"import tofu.logging.derivation.loggable\nimport derevo.derive\n\n@derive(loggable)\ncase class Query(value: String, size: Int, isTagged: Tagged, tag: Tag)\n\n@derive(loggable)\ncase class Tagged(b: Option[Boolean])\n\n@derive(loggable)\nsealed trait Tag\n\n@derive(loggable)\ncase class DatabaseTag(db: String) extends Tag\n\n@derive(loggable)\ncase object InMemoryTag extends Tag\n")),(0,i.yg)("p",null,"so when logged"),(0,i.yg)("h3",{id:"configuring-loggable-generation"},"Configuring Loggable generation"),(0,i.yg)("p",null,"Tofu has several annotations to configure generation of ",(0,i.yg)("inlineCode",{parentName:"p"},"Loggable")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"@hidden")),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-scala:reset"},"import tofu.logging.derivation.{loggable, hidden}\nimport derevo.derive\n\n@derive(loggable)\ncase class User(name: String, @hidden() password: String)\n\n")),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},'User("tofu", "pass")')," will be logged as ",(0,i.yg)("inlineCode",{parentName:"p"},"User{name=tofu}"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"@masked")),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-scala:reset"},"import tofu.logging.derivation.{loggable, masked, MaskMode}\nimport derevo.derive\n\n@derive(loggable)\ncase class Card(@masked(MaskMode.Erase) expirationDate: String, @masked(MaskMode.ForLength(4, 12)) cardNumber: String, @masked() owner: String)\n\n")),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},'Card(737, "1244345632322311", "TOFU PETROV")')," will be logged as ",(0,i.yg)("inlineCode",{parentName:"p"},"Card{expirationDate=...,cardNumber=1244########2311,owner=**** ******}"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"@unembed")),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-scala:reset"},"import tofu.logging.derivation.{loggable, unembed}\nimport derevo.derive\n\n@derive(loggable)\ncase class Scientist(@unembed owner: Person, age: Option[Int])\n\n@derive(loggable)\ncase class Person(name: String)\n")),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},'Room(Person("Karl Sagan"), None)')," will be logged as ",(0,i.yg)("inlineCode",{parentName:"p"},"Room{name=Karl Sagan, age=None}")))),(0,i.yg)("h2",{id:"creation"},"Creation"),(0,i.yg)("p",null,"Creating an instance of ",(0,i.yg)("inlineCode",{parentName:"p"},"Logging")," in Tofu is an effect itself. You can use helper class ",(0,i.yg)("inlineCode",{parentName:"p"},"Logs")," that can produce values\nof type ",(0,i.yg)("inlineCode",{parentName:"p"},"I[Logging[F]]")," (where ",(0,i.yg)("inlineCode",{parentName:"p"},"I")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"F")," are intended to be two different effects, former is a ",(0,i.yg)("inlineCode",{parentName:"p"},"I"),"nitialization\neffect (",(0,i.yg)("inlineCode",{parentName:"p"},"Task")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"IO"),")  and latter is some ReaderT-ish effect or just main program effect type, but they can be the\nsame though) and define a behaviour of your ",(0,i.yg)("inlineCode",{parentName:"p"},"Logging")," instances. An instance of ",(0,i.yg)("inlineCode",{parentName:"p"},"Logs")," is supposed to be shared by\ndifferent parts of user code. It's not a restriction though."),(0,i.yg)("p",null,"Tofu logs are built on top of existing Java logging infrastructure hence each logger for some class needs to have\ndistinctive name, as well as whole logging system has to be configured with a ",(0,i.yg)("inlineCode",{parentName:"p"},"logback.xml")," (default configuration does\nexist though)."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"Logs")," methods close the first requirement in different ways:"),(0,i.yg)("h3",{id:"plain-logging"},"Plain ",(0,i.yg)("inlineCode",{parentName:"h3"},"Logging")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"by asking that name from user:\nFor example here we create named instance and pass it explicitly.")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala:reset"},'import tofu.logging._\nimport tofu.syntax.logging._\nimport tofu.syntax.monadic._\nimport cats._\n\nclass MyService[F[_] : Monad](logger: Logging[F]) {\n  def makeFoo(arg: String): F[Int] =\n    logger.info("Doing simplest thing").as(arg.length) <* logger.debug("Yep, counted length")\n}\n\nobject MyService {\n  def makeNamed[I[_] : Monad, F[_] : Monad](logs: Logs[I, F]): I[MyService[F]] =\n    logs.byName("my-service-log").map(new MyService[F](_))\n}\n\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"by generating that name from type-parameter, which is a class intended to use logging with:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala:reset"},'def makeNamed[I[_] : Monad, F[_] : Monad](logs: Logs[I, F]): I[MyService[F]] =\n  logs.byName("my-service-log").map(new MyService[F](_))\n')),(0,i.yg)("p",null,"Logging instance created by this method for class ",(0,i.yg)("inlineCode",{parentName:"p"},"MyService[IO]")," in package ",(0,i.yg)("inlineCode",{parentName:"p"},"com.bar.foo.pckg")," will be\nnamed ",(0,i.yg)("inlineCode",{parentName:"p"},"com.bar.foo.pckg.MyService")),(0,i.yg)("h3",{id:"typesafe-servicelogging"},"Typesafe ",(0,i.yg)("inlineCode",{parentName:"h3"},"ServiceLogging")),(0,i.yg)("p",null,"Creating plain ",(0,i.yg)("inlineCode",{parentName:"p"},"Logging[F]")," and using it around tends to be error-prune: one can easily pass logger created for\nservice ",(0,i.yg)("inlineCode",{parentName:"p"},"FooService")," instead of ",(0,i.yg)("inlineCode",{parentName:"p"},"BarService"),". Tofu has a solution \u2014 newtype ",(0,i.yg)("inlineCode",{parentName:"p"},"ServiceLogging[F, Service]"),"\nand ",(0,i.yg)("inlineCode",{parentName:"p"},"LoggingCompanion")," which contains simple type alias ",(0,i.yg)("inlineCode",{parentName:"p"},"Log[F[_]] = ServiceLogging[F, Service]"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala:reset"},'import tofu.logging._\nimport tofu.syntax.logging._\nimport tofu.syntax.monadic._\nimport cats._\n\nclass FooService[F[_] : FooService.Log : Monad] {\n  def makeFoo(arg: Int): F[String] =\n    info"Doing yet another simplest thing".as(arg.toString) <* debug"Yep, called toString"\n}\n\nobject FooService extends LoggingCompanion[FooService] {\n  def make[I[_] : Functor, F[_] : Monad](logs: Logs[I, F]): I[FooService[F]] =\n    logs.of[FooService].map(implicit l => new FooService[F])\n}\n\n')),(0,i.yg)("p",null,"Note that using it like ",(0,i.yg)("inlineCode",{parentName:"p"},'logs.named["foo"]')," or ",(0,i.yg)("inlineCode",{parentName:"p"},'logs.byName("foo")')," is going to fail compilation."),(0,i.yg)("p",null,"This is also the intended way to create ",(0,i.yg)("inlineCode",{parentName:"p"},"Logging[F]")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"ServiceLogging[F, Service]")," instance for your classes."),(0,i.yg)("h3",{id:"ways-to-create-logs"},"Ways to create Logs"),(0,i.yg)("p",null,"There are multiple ways to create ",(0,i.yg)("inlineCode",{parentName:"p"},"Logs")," instance, among them:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Logs.sync")," that requires a ",(0,i.yg)("inlineCode",{parentName:"li"},"cats.effect.Sync")," instance for delaying side-effects"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Logs.withContext")," that requires a ",(0,i.yg)("inlineCode",{parentName:"li"},"cats.effect.Sync")," instance for delaying side-effects and a proof that ",(0,i.yg)("inlineCode",{parentName:"li"},"F")," has a\ncontext to log"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Logs.const")," that wraps single ",(0,i.yg)("inlineCode",{parentName:"li"},"Logging")," thus always returning the same instance"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Logs.empty")," that will produce a no-op ",(0,i.yg)("inlineCode",{parentName:"li"},"Logging")," instances"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Logs.combine")," that combines two instances of ",(0,i.yg)("inlineCode",{parentName:"li"},"Logs"),".\n",(0,i.yg)("inlineCode",{parentName:"li"},"Logging")," instance that is created this way will be a combination of two underlying instances, produced by both ",(0,i.yg)("inlineCode",{parentName:"li"},"Logs"),"\n. This means that both ",(0,i.yg)("inlineCode",{parentName:"li"},"Logging")," implementations will be called in sequence")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala:reset"},'import tofu.logging._\n\n// for simplification, you can use whatever F you like\ntype F[A] = cats.effect.IO[A]\n\nclass MyService\nclass MyTaglessService[F[_]]\n// defines simple logging behaviour without any notion of contexts\nval syncLogs = Logs.sync[F, F]\n\n// describing creation of logging instances and logging itself. When being run, this will log a message\nval effect: F[Unit] = for {\n  loggingBN <- syncLogs.byName("my-logger") // you can create instances by name\n  loggingFS <- syncLogs.forService[MyService] // you can create instances by type of your non-tagless-final services\n  loggingFS <- syncLogs.of[MyTaglessService] // you can create instances by type of your tagless-final services\n  _ <- loggingBN.info("This is an INFO message")\n  _ <- loggingFS.warn("This is a WARN message")\n} yield ()\n')),(0,i.yg)("h2",{id:"context-logging"},"Context logging"),(0,i.yg)("p",null,"It is possible to log the context of your computations along with actual log message. Often it comes along with\nstructured logging. To illustrate it consider this pseudocode:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'structuredLogger.info("I am a message", context = Map("transaction_id" -> 2342234, "request_name" -> "req"))\n//it logs \n{ "level": "INFO", "message": "I am a message", "transaction_id": 2342234, "request_name": "req" }\n')),(0,i.yg)("p",null,"That's neat, right? But it is verbose and clumsy to use, so tofu provides an abstraction for it."),(0,i.yg)("p",null,"If you have an instance of ",(0,i.yg)("inlineCode",{parentName:"p"},"tofu.Context")," for your effect type and a ",(0,i.yg)("inlineCode",{parentName:"p"},"Loggable")," for your context, you can have it logged\nautomagically. That is natural \u2014 describe how we can get a context from a computation ",(0,i.yg)("inlineCode",{parentName:"p"},"F")," and a way to represent that\ncontext in log, and we will ensure it will be logged anytime you use ",(0,i.yg)("inlineCode",{parentName:"p"},"Logging")," operations. You can log that context to\nstring as well as use it as a part of structured logging."),(0,i.yg)("h3",{id:"example"},"Example"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala:reset"},'import tofu.WithRun\nimport tofu.logging.derivation.loggable._\nimport tofu.logging.{LoggableContext, Logging, LoggingCompanion, Logs}\nimport cats.{Functor, Monad}\nimport tofu.syntax.console._\nimport tofu.syntax.context._\nimport tofu.syntax.logging._\nimport tofu.syntax.monadic._\nimport tofu.zioInstances.implicits._\nimport zio._\nimport zio.interop.catz._\n\nobject Example extends zio.App {\n\n  class BusinessService[F[_] : BusinessService.Log : Monad] {\n    private def logic(arg: String): String = arg.repeat(3).replace("a", "b")\n\n    def runLogic(arg: String): F[String] =\n      info"Doing some business logic" as logic(arg)\n  }\n\n  object BusinessService extends LoggingCompanion[BusinessService] {\n\n    def make[I[_] : Functor, F[_] : Monad](logs: Logs[I, F]): I[BusinessService[F]] =\n      logs\n        .of[BusinessService]\n        .map(implicit l => new BusinessService[F])\n  }\n\n  case class RequestContext(id: Long, method: String)\n\n  class Server[I[_] : Monad : Logging, F[_] : WithRun[*[_], I, RequestContext]](\n                                                                                 business: BusinessService[F]\n                                                                               ) {\n\n    def handleRequest(request: Server.Request): I[Server.Response] = for {\n      _ <- info"Got request $request"\n      context = RequestContext(request.id, request.method)\n      logicComputation = business.runLogic(request.body)\n\n      result <- runContext[F](logicComputation)(context)\n\n      response = Server.Response(result)\n      _ <- info"Got response $response"\n    } yield response\n\n  }\n\n  object Server {\n\n    case class Request(id: Long, body: String, method: String)\n\n    case class Response(answer: String)\n\n  }\n\n  type Contextual[A] = RIO[RequestContext, A]\n\n  def run(args: List[String]): URIO[ZEnv, ExitCode] = {\n    implicit val loggableContext: LoggableContext[Contextual] =\n      LoggableContext.of[Contextual].instance[RequestContext]\n    val contextLogs: Logs[Task, Contextual] = Logs.withContext[Task, Contextual]\n    val mainLogs: Logs[Task, Task] = Logs.sync[Task, Task]\n\n    for {\n      implicit0(mainLogging: Logging[Task]) <- mainLogs.byName("main")\n      bs <- BusinessService.make(contextLogs)\n      server = new Server[Task, Contextual](bs)\n      userRequest <- readRequest\n      response <- server.handleRequest(userRequest)\n      _ <- putStrLn[Task](s"Got response $response")\n    } yield ()\n\n  }.catchAll(_ => URIO.unit).as(zio.ExitCode.success)\n\n  def readRequest: Task[Server.Request] =\n    (\n      readStrLn[Task]\n        .map(_.toLongOption)\n        .someOrFail(new Exception("Please provide numeric id")),\n      readStrLn[Task],\n      readStrLn[Task]\n      ).mapN(Server.Request.apply)\n\n}\n\n')),(0,i.yg)("h4",{id:"business-logic"},"Business Logic"),(0,i.yg)("p",null,"We got ",(0,i.yg)("inlineCode",{parentName:"p"},"BusinessService")," as our business logic. It does some stuff but most importantly it does not know it has any kind\nof special logging. It just logs some stuff and all it needs for it is ",(0,i.yg)("inlineCode",{parentName:"p"},"Logging")," instance."),(0,i.yg)("p",null,"As you can see it is created with the same factory-pattern as discussed before."),(0,i.yg)("h4",{id:"server"},"Server"),(0,i.yg)("p",null,"Next we have a ",(0,i.yg)("inlineCode",{parentName:"p"},"Server")," of some kind that should get some request, run some business logic on it and then return\nresponse. Also, we want to have all the logs that business logic produces to have special RequestContext in it. To\nachieve this we run the logic in special contextual effect type ",(0,i.yg)("inlineCode",{parentName:"p"},"F")," which then can be evaluated into our main effect ",(0,i.yg)("inlineCode",{parentName:"p"},"I"),"\n.\n(More information on this can be found in scaladoc for ",(0,i.yg)("inlineCode",{parentName:"p"},"tofu.WithRun")," etc.)\nMoreover ",(0,i.yg)("inlineCode",{parentName:"p"},"Server")," itself logs some messages and requires its own instance of ",(0,i.yg)("inlineCode",{parentName:"p"},"Logging"),"."),(0,i.yg)("h4",{id:"loggable-derivation-1"},"Loggable derivation"),(0,i.yg)("p",null,"As one can see in ",(0,i.yg)("a",{parentName:"p",href:"#representation"},"Representation part")," for any of those logged values (like ",(0,i.yg)("inlineCode",{parentName:"p"},"$request"),")  ",(0,i.yg)("inlineCode",{parentName:"p"},"Loggable"),"\ninstance should be in scope. In the example they are generated by macro, we just need to import it:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"}," import tofu.logging.derivation.loggable._\n")),(0,i.yg)("h4",{id:"running"},"Running"),(0,i.yg)("p",null,"It is a simple ZIO-app that reads user input from console and passes it to server. So when running possible output will\nlook like this, if ran with ",(0,i.yg)("inlineCode",{parentName:"p"},"ConsoleContextLayout")," in ",(0,i.yg)("inlineCode",{parentName:"p"},"logback.xml"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"sbt>run\n10102\nfoo bar body\nGET\n23:20:14 INFO  main - Got request Request{id=10102,body=foo bar body,method=GET}\n23:20:14 INFO  c.t.c.n.c.Example$BusinessService - Doing some business logic\n [method=GET, id=10102]\n23:20:14 INFO  main - Got response Response{answer=foo bbr bodyfoo bbr bodyfoo bbr body}\nGot response Response(foo bbr bodyfoo bbr bodyfoo bbr body)\n")),(0,i.yg)("h2",{id:"syntax-extensions"},"Syntax extensions"),(0,i.yg)("p",null,"It's much more convenient to use pre-defined syntax extensions for logging operations since they do all heavy lifting\nfor you:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala:reset"},'import cats.effect._\nimport cats.syntax.functor._\nimport cats.{Monad, Show, Functor}\nimport tofu.logging._\nimport tofu.syntax.logging._\n\ncase class User(name: String, surname: String)\nobject User {\n  implicit val userShow: Show[User]         = user => s"name=${user.name}, surname=${user.surname}"\n  implicit val userInstance: Loggable[User] = Loggable.show\n}\n\nval user: User = User("name", "surname")\n\nclass MyService[F[_]: Logging: Monad] {\n  def doLogging: F[Unit] =\n    for {\n      _ <- info"This is a syntax demo: $user"\n    } yield ()\n}\n\nobject MyService {\n  def apply[I[_]: Functor, F[_]: Monad](implicit logs: Logs[I, F]): I[MyService[F]] = {\n    logs.forService[MyService[F]].map(implicit l => new MyService[F])\n  }\n}\n\n// An instance of `Logs` is supposed to be shared between mupltiple classes (or a single one for a whole application)\n// Note that initializing effect of your application may differ from logging effect.\nimplicit val logs: Logs[IO, IO] = Logs.sync[IO, IO]\n\nval io: IO[Unit] = for {\n  service <- MyService[IO, IO]\n  _       <- service.doLogging\n} yield ()\n\nio.unsafeRunSync()\n// 13:56:26.918 [main] INFO tofu.logging.Test$MyService - This is a syntax demo: name=name, surname=surname\n')),(0,i.yg)("p",null,"Using a syntax we achieve a few important goals.",(0,i.yg)("br",{parentName:"p"}),"\n","First, it will log a message containing a string representation of your value of type ",(0,i.yg)("inlineCode",{parentName:"p"},"User")," as you defined it\nin ",(0,i.yg)("inlineCode",{parentName:"p"},"Loggable")," instance.",(0,i.yg)("br",{parentName:"p"}),"\n","Second, it will create a ",(0,i.yg)("inlineCode",{parentName:"p"},"LoggedValue")," from your ",(0,i.yg)("inlineCode",{parentName:"p"},"Loggable")," description and pass it to underlying logger and\nyour ",(0,i.yg)("inlineCode",{parentName:"p"},"LogRendered"),", so your structured logging will work as expected."),(0,i.yg)("h2",{id:"integration-with-logs4cats"},"Integration with logs4cats"),(0,i.yg)("p",null,"There is a library for effectual logging named ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/typelevel/log4cats"},"log4cats")," which shares\nthe goal of representing logging as an effect and providing the ability to log context values. It is used by some of the\nopen-source libraries which may require you to pass an instance of ",(0,i.yg)("inlineCode",{parentName:"p"},"org.typelevel.log4cats.Logger")," to it in order to\nlog something. Module ",(0,i.yg)("inlineCode",{parentName:"p"},"tofu-logging-log4cats")," contains a helper that can create an instance of log4cats ",(0,i.yg)("inlineCode",{parentName:"p"},"Logger")," from\nour existing\n",(0,i.yg)("inlineCode",{parentName:"p"},"tofu.logging.Logging")," one. If our ",(0,i.yg)("inlineCode",{parentName:"p"},"Logging")," instance is contextual, it will continue leveraging that despite being\nwrapped in log4cats ",(0,i.yg)("inlineCode",{parentName:"p"},"Logger"),". Moveover, it will log context values that are passed to log4cats ",(0,i.yg)("inlineCode",{parentName:"p"},"Logger")," API\nas ",(0,i.yg)("inlineCode",{parentName:"p"},"Map[String, String]"),".",(0,i.yg)("br",{parentName:"p"}),"\n","This means that not only you will not lose your context, but additional values that are passed to ",(0,i.yg)("inlineCode",{parentName:"p"},"Logger")," will also be\nlogged.",(0,i.yg)("br",{parentName:"p"}),"\n","Let's take a look at the example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala:reset"},'import org.typelevel.log4cats.{Logger, StructuredLogger}\nimport tofu.env.Env\nimport tofu.logging._\n\n// Suppose we have some external APIs that leverage log4cats\'s Logger and StructuredLogger\ndef logWithLog4Cats[F[_]](implicit logger: Logger[F]): F[Unit] =\n    logger.info("Hello Tofu!")\n\ndef logWithLog4CatsContextual[F[_]](implicit logger: StructuredLogger[F]): F[Unit] =\n    logger.info(Map("field" -> "value"))("Hello contextual Tofu!")\n\n// And we have our own context that can be logged as a structure\ncase class Context(start: Long)\nobject Context {\n  implicit val loggable: Loggable[Context] = new DictLoggable[Context] {\n    override def fields[I, V, R, S](a: Context, i: I)(implicit r: LogRenderer[I, V, R, S]): R =\n      r.addInt("start", a.start.toInt, i)\n    override def logShow(a: Context): String                                                  =\n      a.toString\n  }\n}\n\n// This context will be embedded in our Env monad and be logged at each logging call\ntype AppEnv[A] = Env[Context, A]\nimplicit val loggableContext: LoggableContext[AppEnv] = LoggableContext.of[AppEnv].instance\nval logs: Logs[AppEnv, AppEnv]                        = Logs.withContext[AppEnv, AppEnv]\n\n// first we need to import converter function\nimport tofu.logging.log4cats._\n \n// then we can create an instance of Logger, passing an instance of tofu.logging.Logging implicitly\nval env1: AppEnv[Unit] =\n  logs.byName("Main").flatMap { implicit logging =>\n    implicit val log4catsLogger: StructuredLogger[AppEnv] = toLog4CatsLogger\n    logWithLog4Cats *> logWithLog4CatsContextual\n  }\n\n// or passing it explicitly in case you have more than one Logging instance in scope\nval env2: AppEnv[Unit] =\n  logs.byName("Main").flatMap { logging =>\n    implicit val log4catsLogger: StructuredLogger[AppEnv] = toLog4CatsLogger(logging)\n    logWithLog4Cats *> logWithLog4CatsContextual\n  }\n\n// you can also create an instance of Logger for each call, but this is not advised since it will make unnecessary allocations\nval env3: AppEnv[Unit] =\n  logs.byName("Main").flatMap(implicit logging => logWithLog4Cats *> logWithLog4CatsContextual)\n\n// we can then import Scheduler and run our Env with some context\nimport monix.execution.Scheduler.Implicits.global\n\n(for {\n  _ <- env1.run(Context(123))\n  _ <- env2.run(Context(456))\n  _ <- env3.run(Context(789))\n} yield ()).runSyncUnsafe(Duration.Inf)\n\n// If we have a configured layout for structured logging, supporting context values (i.e. tofu.logging.ElkLayout)\n// we will see JSON logs that contain not only values from our Context, but also values that were passed to log4cats Logger by the external API\n// {"@timestamp":"2020-10-31T14:11:31.059Z","loggerName":"Main","threadName":"main","level":"INFO","message":"Hello Tofu!","start":123}\n// {"@timestamp":"2020-10-31T14:11:31.167Z","loggerName":"Main","threadName":"main","level":"INFO","message":"Hello contextual Tofu!","start":123,"field":"value"}\n// {"@timestamp":"2020-10-31T14:11:31.168Z","loggerName":"Main","threadName":"main","level":"INFO","message":"Hello Tofu!","start":456}\n// {"@timestamp":"2020-10-31T14:11:31.168Z","loggerName":"Main","threadName":"main","level":"INFO","message":"Hello contextual Tofu!","start":456,"field":"value"}\n// {"@timestamp":"2020-10-31T14:11:31.169Z","loggerName":"Main","threadName":"main","level":"INFO","message":"Hello Tofu!","start":789}\n// {"@timestamp":"2020-10-31T14:11:31.169Z","loggerName":"Main","threadName":"main","level":"INFO","message":"Hello contextual Tofu!","start":789,"field":"value"}\n')))}m.isMDXComponent=!0}}]);