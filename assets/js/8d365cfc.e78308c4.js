"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8565],{5627:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>c,toc:()=>d});var r=a(8168),t=a(8587),i=(a(6540),a(5680)),o=["components"],l={},s="Kind numbers",c={unversionedId:"internal/kind-enumeration",id:"internal/kind-enumeration",title:"Kind numbers",description:"Naming kinds is hard. Suppose you have Function1[A, B] = A => B and FunctionK[F[], G[]] = [A] => F[A] => G[A]",source:"@site/../docs/internal/kind-enumeration.md",sourceDirName:"internal",slug:"/internal/kind-enumeration",permalink:"/tofu/docs/internal/kind-enumeration",draft:!1,tags:[],version:"current",lastUpdatedBy:"Tofu Bot",lastUpdatedAt:1752587346,formattedLastUpdatedAt:"Jul 15, 2025",frontMatter:{}},p={},d=[],m={toc:d},g="wrapper";function u(e){var n=e.components,a=(0,t.A)(e,o);return(0,i.yg)(g,(0,r.A)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"kind-numbers"},"Kind numbers"),(0,i.yg)("p",null,"Naming kinds is hard. Suppose you have ",(0,i.yg)("inlineCode",{parentName:"p"},"Function1[A, B] = A => B")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"FunctionK[F[_], G[_]] = [A] => F[A] => G[A]")),(0,i.yg)("p",null,"Suppose you have ",(0,i.yg)("inlineCode",{parentName:"p"},"T[_[_, _], _, _]")," how to correctly name transformation between such types? ",(0,i.yg)("inlineCode",{parentName:"p"},"FunctionK_KK_KK")," ?",(0,i.yg)("br",{parentName:"p"}),"\n","Alphabetical codes could be hard to read and disambiguate. So I propose enumerate them all with a simple scheme."),(0,i.yg)("p",null,"Here we suppose that ",(0,i.yg)("inlineCode",{parentName:"p"},"* = Type")," is a Kind of  inhabitable types and ",(0,i.yg)("inlineCode",{parentName:"p"},"k1 -> k2")," where ",(0,i.yg)("inlineCode",{parentName:"p"},"k1")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"k2")," are kind is itself kind that has single type argument of kind ",(0,i.yg)("inlineCode",{parentName:"p"},"k1")," and result of kind ",(0,i.yg)("inlineCode",{parentName:"p"},"k2"),". Those arrows in absence of parenthesis are associated right.\nAll scala kinds we suppose to be naturally curried.  "),(0,i.yg)("p",null,"So ",(0,i.yg)("inlineCode",{parentName:"p"},"T[_[_, _], _, _]")," becomes ",(0,i.yg)("inlineCode",{parentName:"p"},"(* -> * -> *) -> * -> * -> *")," or  ",(0,i.yg)("inlineCode",{parentName:"p"},"(* -> (* -> *)) -> (* -> (* -> *))"),"\nand ",(0,i.yg)("inlineCode",{parentName:"p"},"T[_[_[_]], _[_[_]]]")," becomes ",(0,i.yg)("inlineCode",{parentName:"p"},"((* -> *) -> *) -> ((* -> *) -> *) -> *")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"((* -> *) -> *) -> (((* -> *) -> *) -> *)"),"."),(0,i.yg)("p",null,"We can consider those elements as binary trees, elements of  "),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"sealed trait Bin\ncase object Leaf extends Bin\ncase class Branch(l: Bin, r: Bin) extends Bin\n")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"*")," corresponds to ",(0,i.yg)("inlineCode",{parentName:"p"},"Leaf")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"k1 -> k2")," corresponds to ",(0,i.yg)("inlineCode",{parentName:"p"},"Branch(k1, k2)"),(0,i.yg)("br",{parentName:"p"}),"\n","For those trees we defined rank as following:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"lazy val rank: Bin => Int = {\n    case Leaf => 0\n    case Branch(b1, b2) => (rank(b1) max rank(b2)) + 1\n}\n")),(0,i.yg)("p",null,"We can calculate count of different binary trees for each rank as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"val sizeUpToRank: LazyList[BigInt] = LazyList.from(0).map{x =>  \n    if(x == 0) 0 else rankSize(x - 1) + sizeUpToRank(x - 1)\n}\n\nval rankSize: LazyList[BigInt] = LazyList.from(0).map{x =>\n    if(x <= 1) 1  \n    else 2 * sizeUpToRank(x - 1) * rankSize(x - 1) + rankSize(x - 1) * rankSize(x - 1)\n}\n")),(0,i.yg)("p",null,"Now we can assign unique natural index to Binary trees inside the rank and globally"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"lazy val rankIndex: Bin => BigInt = {\n    case Leaf => 0\n    case tree@Branch(tl, tr) =>\n        val r   = rank(tree) - 1\n        val q   = rankSize(r)\n        val u   = sizeUpToRank(r) * q\n        if(rank(tl) < r)\n            index(tl) * q + rankIndex(tr)\n        else if(rank(tr) < r)\n            index(tr) * q + rankIndex(tl) + u  \n        else  \n            rankIndex(tl) * q + rankIndex(tr) + 2 * u\n}\n\ndef index(tree: Bin): BigInt = sizeUpToRank(rank(tree)) + rankIndex(tree)\n\nindex(Branch(Branch(Leaf, Leaf), Leaf))\n")),(0,i.yg)("p",null,"We can provide string representations for our trees."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},'lazy val args: Bin => LazyList[Bin] = {\n    case Leaf => LazyList.empty\n    case Branch(t1, t2) => t1 #:: args(t2)\n}\n\nlazy val toStarString: Bin => String = {\n    case Leaf => "*"\n    case tree => args(tree).iterator.map {\n        case Leaf => "*"\n        case branch => s"(${toStarString(branch)})"\n    }.mkString("", " -> ", " -> *")\n}\n\nlazy val toScalaString: Bin => String = {\n    case Leaf => "T"\n    case tree => args(tree).iterator.map {\n        case Leaf => "_"\n        case branch => s"_${toScalaString(branch)}"\n    }.mkString("[", ", ", "]")\n}\n')),(0,i.yg)("p",null,"Now we can generate some trees"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"val trees = LazyList.iterate((LazyList[Bin](), LazyList[Bin](Leaf))){ case (prev, cur) =>  \n    val xs = for(tl <- prev; tr <- cur) yield Branch(tl, tr)\n    val ys = for(tr <- prev; tl <- cur) yield Branch(tl, tr)\n    val zs = for(tl <- cur; tr <- cur)  yield Branch(tl, tr)\n    val next = xs #::: ys #::: zs\n    (prev #::: cur, next)\n}.flatMap(_._2).map(t => (toScalaString(t), index(t)))\n\n")),(0,i.yg)("p",null,"Here we can find that our desired shape for ",(0,i.yg)("inlineCode",{parentName:"p"},"[_[_, _], _, _]")," has number 17"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},'trees.find(_._1 == "[_[_, _], _, _]").get._2\n')),(0,i.yg)("p",null,"Therefore we can name our kind-specific transformation as ",(0,i.yg)("inlineCode",{parentName:"p"},"FunctionKn17")," meaning this is transformation between typeconstructors of type with index 17 having following form"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala"},"type FunctionKn17[A[_[_, _], _, _], B[_[_, _], _, _]] = [F[_, _], E, A] => A[F, E, A] => B[F, E, A]\n")),(0,i.yg)("p",null,"We can also reverse kind getting by index"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"def byIndex(x: BigInt): Bin = if(x == 0) Leaf else {\n    val r = sizeUpToRank.indexWhere(_ > x) - 1\n    byIndexInRank(x - sizeUpToRank(r), r)\n}\n\ndef byIndexInRank(x: BigInt, r: Int): Bin = if(r == 0) Leaf else {\n    val q = rankSize(r - 1)\n    val u = sizeUpToRank(r - 1) * q\n    if(x < u)\n        Branch(byIndex(x / q), byIndexInRank(x % q, r - 1))\n    else if(x < 2 * u){\n        val x1 = x - u\n        Branch(byIndexInRank(x1 % q, r - 1), byIndex(x1 / q))\n    } else {\n        val x1 = x - 2 * u\n        Branch(byIndexInRank(x1 / q, r - 1), byIndexInRank(x1 % q, r - 1))\n    }\n}\n")),(0,i.yg)("p",null,"we may check that these functions are indeed isomorphim in natural numbers"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"Iterator.range(0, 100).forall(i => index(byIndex(i)) == i)\n")),(0,i.yg)("p",null,"So now if one need to get signature for Kind number 17, they may write"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-scala",metastring:"mdoc",mdoc:!0},"toScalaString(byIndex(17))\ntoStarString(byIndex(17))\n")))}u.isMDXComponent=!0},5680:(e,n,a)=>{a.d(n,{xA:()=>p,yg:()=>u});var r=a(6540);function t(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),a.push.apply(a,r)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach(function(n){t(e,n,a[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))})}return e}function l(e,n){if(null==e)return{};var a,r,t=function(e,n){if(null==e)return{};var a,r,t={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||(t[a]=e[a]);return t}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(t[a]=e[a])}return t}var s=r.createContext({}),c=function(e){var n=r.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},p=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef(function(e,n){var a=e.components,t=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(a),g=t,u=d["".concat(s,".").concat(g)]||d[g]||m[g]||i;return a?r.createElement(u,o(o({ref:n},p),{},{components:a})):r.createElement(u,o({ref:n},p))});function u(e,n){var a=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var i=a.length,o=new Array(i);o[0]=g;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[d]="string"==typeof e?e:t,o[1]=l;for(var c=2;c<i;c++)o[c]=a[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}g.displayName="MDXCreateElement"}}]);